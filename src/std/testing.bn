import "./sys" as sys
import "./string" as string
import "./io" as io

alias T = struct {
    bool failure,
    chr* suite_name,
    chr* test_name,
    int test_no,
    int* fds,
    File* out,
}
int T_ptr_size = 48


-- initialize test suite for a given file
T* init(chr* filename) {
    T* t = (T*) sys.malloc(T_ptr_size)
    t.suite_name = filename
    t.fds = (int*) sys.malloc(2 * 32)

    stderr := io.fdopen(io.STDERR, "w")
    io.fprintf(stderr, "Running tests in %s\0A", filename)
    return t
}


-- prepares `T` data structure for a new test
void setup(T* t, chr* test_name) {
    t.failure = false
    t.test_name = test_name

    sys.assert(sys.pipe(t.fds) >= 0, "unable to open pipe")

    t.test_no = 0
    fds := t.fds
    t.out = io.fdopen(fds[io.STDOUT], "w")
    sys.assert(t.out != null, "unable to open stdout")
}


-- print test outcome
void run(T* t, int _unused) {
    fds := t.fds

    io.fflush(t.out)
    io.close(fds[io.STDOUT])

    stderr := io.fdopen(io.STDERR, "w")
    if t.failure {
        io.fprintf(stderr, "[ \1B[31mERROR\1B[0m ] %s: \0A", t.test_name)

        _read_all(fds[io.STDIN])
    } elif t.test_no == 0 {
        io.fprintf(stderr, "[ \1B[33mWARN\1B[0m  ] %s: no asserts found\0A", t.test_name)

    } else {
        io.fprintf(stderr, "[ \1B[32mOK\1B[0m    ] %s\0A", t.test_name)
    }
    io.close(fds[io.STDIN])
}


void cleanup(T* t) {
    io.fclose(t.out)
    sys.free((chr*) t.fds)
    sys.free((chr*) t)
}

void _read_all(int fd) {
    int len = 1024
    chr* buf = sys.malloc(len)
    int read = 0

    bool quit = false
    for ; quit == false ; {
        read = io.read(fd, buf, len)
        if read > 0 {
            io.write(io.STDERR, buf, len)
        } else {
            quit = true
        }
    }

    io.write(io.STDERR, "\0A", 1)
    sys.free(buf)
}

void fail(T* t) {
    t.failure = true
    io.fprintf(t.out, "#%d: ", t.test_no)
}


-- assert functions
void assert_equal_int(T* t, int expect, got) {
    t.test_no = t.test_no + 1
    if expect != got {
        fail(t)
        io.fprintf(t.out, "expected '%d', got '%d'\0A", expect, got)
    }
}

void assert_equal_chr(T* t, chr expect, got) {
    t.test_no = t.test_no + 1
    if expect != got {
        fail(t)
        io.fprintf(t.out, "expected '%c' (%d), got '%c' (%d)\0A", expect, expect, got, got)
    }
}

void assert_true(T* t, chr* label, bool val) {
    t.test_no = t.test_no + 1
    if val == false {
        fail(t)
        io.fprintf(t.out, "value %s is not truthy\0A", label)
    }
}

void assert_equal_str(T* t, chr* expect, got) {
    t.test_no = t.test_no + 1
    if got == null {
        fail(t)
        io.fprintf(t.out, "expected '%s', got (null)\0A", expect, got)
    } elif string.strcmp(expect, got) != 0 {
        fail(t)
        io.fprintf(t.out, "expected '%s', got '%s'\0A", expect, got)
    }
}

void assert_null(T* t, chr* ptr) {
    t.test_no = t.test_no + 1
    if ptr != null {
        fail(t)
        io.fprintf(t.out, "expected null pointer, got: %p", ptr)
    }
}

void assert_not_null(T* t, chr* ptr) {
    t.test_no = t.test_no + 1
    if ptr == null {
        fail(t)
        io.fprintf(t.out, "expected pointer, got: (null)")
    }
}

File* tempfile(chr* content) {
    fd := io.tmpfile()
    io.fprintf(fd, content)
    io.rewind(fd)
    return fd
}
