import "../io" as io
import "../ioutil" as ioutil
import "../string" as string
import "../sys" as sys

import "../ast/errors" as errors
import "../ast/lexer" as lexer
import "../ast/parser" as parser
import "../ast/parser.debug" as parser_debug
import "../ast/peeker" as peeker
import "../ast/syntax" as syntax

import "./builtin_templates" as builtin
import "./llvm" as llvm
import "./shunting_yard" as sy
import "./types" as types
import "./lang_types" as lang_types

bool DEBUG_INTERNALS=false


types.Type* type_clone(types.Type* t) {
    if t == null {
        return (types.Type*) null
    }

    types.Type* clone = (types.Type*) sys.malloc(sizeof(types.Type))
    clone.of = t.of
    clone.next = type_clone(t.next)
    clone.repr = t.repr
    clone.container = t.container
    clone.info = t.info
    return clone
}

str get_root() {
    project_root := sys.getenv("COFFEE_ROOT")
    if project_root == null {
        home := sys.getenv("HOME")
        io.asprintf(&project_root, "%s/.coffee", home)
    }
    return project_root
}

types.Type* new_type() {
    type := (types.Type*) sys.malloc(sizeof(types.Type))
    type.info = null
    type.repr = null
    type.container = null
    type.of = null
    type.next = null
    return type
}

void copy_type(types.Type* dest, types.Type* src) {
    dest.container = src.container
    dest.info = src.info
    dest.repr = src.repr

    if dest.of != src.of {
        dest.of = src.of
        copy_type(dest.of, src.of)
    }

    if dest.next != src.next {
        dest.next = src.next
        copy_type(dest.next, src.next)
    }
}

chr SCOPE_GLOBAL = '@'
chr SCOPE_LOCAL = '%'
chr SCOPE_CONST = ' '


types.AssignableInfo* new_assignable_info(parser.Node* node) {
    ptr := (types.AssignableInfo*) sys.malloc(sizeof(types.AssignableInfo))
    ptr.scope = SCOPE_CONST
    ptr.id = null
    ptr.name_type = null
    ptr.name = ""
    ptr.type = null

    -- copy line and char of line from specified node
    if node != null {
        ptr.line = node.line
        ptr.char_of_line = node.char_of_line
        ptr.filename = node.filename
    } else {
        ptr.line = 0
        ptr.char_of_line = 0
        ptr.filename = null
    }
    return ptr
}

void set_assignable_id(types.AssignableInfo* info, chr scope, chr* id) {
    info.id = id
    info.scope = scope
}

chr* repr_assignable_id(types.AssignableInfo* info) {
    if info.scope == SCOPE_CONST {
        return info.id
    }
    chr* buf
    io.asprintf(&buf, "%c%s", info.scope, info.id)
    return buf
}




void set_assignable_tmp_id(types.CompilerCtx* ctx, types.AssignableInfo* info) {
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".tmp%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_LOCAL, tmp_buff)
}

types.ModuleLookup* get_module(types.CompilerCtx* ctx, str filename) {
    for m := ctx.modules; m != null; m = m.next {
        if string.strcmp(m.abspath, filename) == 0 {
            return m
        }
    }
    return (types.ModuleLookup*) null
}
types.ModuleLookup* get_current_module(types.CompilerCtx* ctx) {
    return get_module(ctx, ctx.current_module)
}

int new_uid(types.CompilerCtx* ctx) {
    uid := ctx.counter
    ctx.counter = ctx.counter + 1
    return uid
}

types.CompilerCtx* new_context(io.File* fd, str filename) {
    types.CompilerCtx* ctx = (types.CompilerCtx*) sys.malloc(sizeof(types.CompilerCtx))
    ctx.ir = fd
    ctx.root = (parser.Node*) null
    ctx.errors = null
    ctx.counter = 0
    ctx.globals = null
    ctx.anon_functions = null
    ctx.current_module = filename

    grammar_file := ioutil.str_as_file(syntax.grammar())
    if grammar_file == null {
        return (types.CompilerCtx*) null
    }
    grammar_ctx := parser.new_context(grammar_file)
    io.fclose(grammar_file)
    ctx.grammar = parser.parse_grammar(grammar_ctx)

    ctx.modules = (types.ModuleLookup*) sys.malloc(sizeof(types.ModuleLookup))
    ctx.modules.abspath = filename
    ctx.modules.scopes = null
    ctx.modules.prefix = ""
    ctx.modules.next = null

    return (types.CompilerCtx*) ctx
}

void push_scope(types.CompilerCtx* ctx, chr* type, begin_id, end_id, types.Type* t) {
    s := (types.Scope*) sys.malloc(sizeof(types.Scope))

    m := get_current_module(ctx)
    s.prev = m.scopes
    s.item = null
    s.type = type
    s.begin_id = begin_id
    s.end_id = end_id
    s.return_type = t
    m.scopes = s
}

void pop_scope(types.CompilerCtx* ctx) {
    -- TODO: free this scope -> s := ctx.scopes
    m := get_current_module(ctx)
    sys.assert(m.scopes != null, ":coffee-error: 'pop_scope' called when module.scopes is null")
    m.scopes = m.scopes.prev
}


bool compile_file(types.CompilerCtx* ctx, parser.Node* stmt, str filepath) {
    int input_fd = io.open(filepath, io.O_RDONLY)
    if input_fd <= 0 {
        chr* err_msg
        io.asprintf(&err_msg, "Unable to open file: '%s'", stmt)
        new_error(ctx, stmt, err_msg)
        return false
    }

    p := peeker.new(input_fd)
    p.filename = filepath

    tokens := lexer.tokenize(p, false)
    ast := parser.ast(ctx.grammar, "start", tokens)

    if ast.err != null {
        append_error(ctx, ast.err)
    }
    return compile(ctx, ast.node)
}


bool compile(types.CompilerCtx* ctx, parser.Node* ast) {
    if ctx.errors == null {
        compile_ast(ctx, ast)
    }

    if ctx.errors != null {
        for err := ctx.errors; err != null; err = err.next {
            if err.reported == false {
                errors.report(err.err)
                err.reported = true
            }
        }
        return true
    }

    return false
}

void mark_weak_global(types.CompilerCtx* ctx, str id) {
    for g := ctx.globals; g != null; g = g.next {
        if g.weak & string.strcmp(g.identifier, id) == 0 {
            g.compiled = true
            break
        }
    }
}


void compile_ast(types.CompilerCtx* ctx, parser.Node* ast) {
    if string.strcmp(ast.type, "start") != 0 {
        new_error(ctx, ast, "Expecting 'start' expression")
        return
    }

    -- push global context scope
    push_scope(ctx, "global", (chr*) null, (chr*) null, (types.Type*) null)

    start := ast.children
    if string.strcmp(start.type, "head_comment") == 0 {
        start = start.next
    }

    -- pre-parse 'extern', 'function', 'globals'
    for stmt := start; stmt != null; stmt = stmt.next {
        compile_statement(ctx, stmt.children, true)
    }

    if ctx.errors != null {
        return
    }

    for s := start; s != null; s = s.next {
        compile_statement(ctx, s.children, false)
        compile_anon_fn(ctx)
    }

    -- add globals
    mod := get_current_module(ctx)
    if string.strcmp(mod.prefix, "") == 0 {
        for g := ctx.globals; g != null; g = g.next {
            compile_global(ctx, g)
        }
    }
}


void compile_global(types.CompilerCtx* ctx, types.GlobalName* g) {
    if g.compiled {
        return
    }

    if string.strcmp(g.global_type, "string") == 0 {
        io.fprintf(ctx.ir, "%s = constant %s %s\n", repr_assignable_id(g.info), lang_types.repr(ctx, g.info.type), g.identifier)
    } elif string.strcmp(g.global_type, "extern") == 0 {
        compile_extern(ctx, g.info)
    }

    g.compiled = true
}

void compile_extern(types.CompilerCtx* ctx, types.AssignableInfo* info) {
    io.fprintf(ctx.ir, "declare %s %s(", lang_types.repr(ctx, info.type.of), repr_assignable_id(info))
    for pt := info.type.of.next; pt != null; pt = pt.next {
        if pt != info.type.of.next {
            io.fprintf(ctx.ir, ", ")
        }
        io.fprintf(ctx.ir, "%s", lang_types.repr(ctx, pt))
    }
    io.fprintf(ctx.ir, ")\n")
}


chr* get_mod_prefix(types.CompilerCtx* ctx, str module_abspath) {
    m := get_current_module(ctx)
    return m.prefix
}


str name_mangle(types.CompilerCtx* ctx, parser.Node* fn, str original_name, types.Type* type) {
    chr* mangled_name

    chr* prefix = get_mod_prefix(ctx, fn.filename)
    io.asprintf(&mangled_name, "%s%s", prefix, original_name)
    if string.strcmp(type.container, "function") == 0 {
        -- function  name is the concatenation of module, original name
        -- return value and parameters type
        if string.strcmp(mangled_name, "main") != 0 {
            chr* tmp_buff
            chr* swap_var
            for tp := type.of; tp != null; tp = tp.next {
                io.asprintf(&tmp_buff, "%s.%s", mangled_name, type_abbr(tp))

                swap_var = tmp_buff
                tmp_buff = mangled_name
                mangled_name = swap_var
                sys.free(tmp_buff)
            }
        }
    }

    return mangled_name
}

void compile_statement(types.CompilerCtx* ctx, parser.Node* stmt, bool shallow) {
    types.AssignableInfo* info
    types.Type* return_type
    chr* err_buf
    chr* tmp_buff

    if string.strcmp(stmt.type, "NL") == 0 {
        return
    } elif string.strcmp(stmt.type, "global") == 0 {
        assignable := skip_to_type(stmt.children, "assignable")
        a_info := compile_assignable(ctx, assignable)
        if a_info == null {
            return
        }

        info = new_assignable_info(stmt)
        global_name := stmt.children.next.value
        set_assignable_id(info, SCOPE_GLOBAL, global_name)
        info.type = a_info.type
        info.name_type = "variable"

        if shallow == true {
            define_assignable(ctx, stmt, global_name, info)
        } else {
            io.fprintf(ctx.ir, "%s = constant %s %s\n", repr_assignable_id(info), lang_types.repr(ctx, info.type), repr_assignable_id(a_info))
        }

    } elif string.strcmp(stmt.type, "typealias") == 0 {

        type_name := stmt.children.next.value

        if shallow == true {
            info = new_assignable_info(stmt)
            mod_from := get_current_module(ctx)
            io.asprintf(&tmp_buff, "%s.%s.type", mod_from.prefix, type_name)
            set_assignable_id(info, SCOPE_LOCAL, tmp_buff)

            info.name_type = "typealias"
            info.line = stmt.line
            info.char_of_line = stmt.char_of_line
            info.type = new_type()

            define_assignable(ctx, stmt, type_name, info)

            type_decl := skip_to_type(stmt.children, "type")
            type_struct := node_to_type(ctx, type_decl.children)

            copy_type(info.type, type_struct)
            info.type = type_struct

        } else {
            scope := find_defined_str(ctx, ctx.current_module, type_name)
            info = scope.info
            io.fprintf(ctx.ir, "%s = type %s\n", repr_assignable_id(info), lang_types.repr(ctx, info.type))
        }

    } elif string.strcmp(stmt.type, "extern") == 0 {
        info = new_assignable_info(stmt)
        info.type = syn_function_type(ctx, stmt.children.next)
        info.name_type = "extern"

        fn_name := stmt.children.next.next.value
        set_assignable_id(info, SCOPE_GLOBAL, fn_name)

        -- copy defined function return type
        return_type = new_type()
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        -- if extern is present in week globals, don't define it

        if shallow == false {
            mark_weak_global(ctx, fn_name)
            define_global(ctx, fn_name, "extern", info, true, true)
            compile_extern(ctx, info)
        } else {
            define_assignable(ctx, stmt, fn_name, info)
        }

    } elif string.strcmp(stmt.type, "function") == 0 {
        -- function definition
        info = new_assignable_info(stmt)
        info.name_type = "function"
        info.type = syn_function_type(ctx, stmt.children)

        name := syn_function_name(stmt)
        tmp_buff = name_mangle(ctx, stmt, name, info.type)
        set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

        if shallow == true {
            define_assignable(ctx, stmt, name, info)
        } else {

            -- copy defined function return type
            return_type = new_type()
            copy_type(return_type, info.type.of)


            io.fprintf(ctx.ir, "define %s %s(", lang_types.repr(ctx, return_type), repr_assignable_id(info))
            params := syn_function_params(stmt.children)

            types.Type* param_type
            for param_ptr := params; param_ptr != null ; {
                if param_ptr != params {
                    param_ptr = param_ptr.next
                    io.fprintf(ctx.ir, ", ")
                }
                if string.strcmp(param_ptr.type, "type") == 0 {
                    param_type = node_to_type(ctx, param_ptr.children)
                    param_ptr = param_ptr.next
                }
                io.fprintf(ctx.ir, "%s %%.%s.arg", lang_types.repr(ctx, param_type), param_ptr.value)
                param_ptr = param_ptr.next
            }
            -- build function parameters string
            io.fprintf(ctx.ir, ") {\n")
            push_scope(ctx, "function", (chr*) null, (chr*) null, return_type)
            compile_fn_params(ctx, params)

            fn_block := skip_to_type(stmt.children, "block")
            compile_block(ctx, fn_block)
            pop_scope(ctx)


            parser.Node* last_valid_instruction = (parser.Node*) null

            -- check if last instruction is a return stmt
            -- otherwise add implicit void return
            -- or signal an error

            check_n_add_implicit_return(ctx, fn_block, return_type)
            io.fprintf(ctx.ir, "}\n")
        }

    } elif string.strcmp(stmt.type, "import") == 0 {
        if shallow == true {
            -- 1. get file cwd
            -- check if module is already imported in module lookup
            mod_name := stmt.children.next.value
            mod_name_len := string.strlen(mod_name)

            -- remove apices from string
            trimmed_path := sys.malloc(mod_name_len -1)
            for i := 1 ; i < mod_name_len - 1; i = i + 1 {
                trimmed_path[i - 1] = mod_name[i]
            }
            trimmed_path[mod_name_len -2] = '\x00'

            mod_abspath := resolve_import_path(ctx, stmt, trimmed_path)
            relpath := sys.realpath(mod_abspath, sys.malloc(4096))

            if relpath == null {
                io.asprintf(&err_buf, "Unable to import '%s' no such file or directory. (%s)", mod_name, mod_abspath)
                new_error(ctx, stmt, err_buf)
                return
            }
            mod_abspath = relpath


            -- define module lookup if not found
            types.ModuleLookup* m
            types.ModuleLookup* mod = (types.ModuleLookup*) null

            for m = ctx.modules; m != null & mod == null; m = m.next {
                if string.strcmp(mod_abspath, m.abspath) == 0 {
                    mod = m
                }
            }

            asname := stmt.children.next.next.next.value

            if mod == null {
                mod = (types.ModuleLookup*) sys.malloc(sizeof(types.ModuleLookup))
                mod.abspath = mod_abspath
                mod.next = null
                mod.scopes = null
                io.asprintf(&mod.prefix, "m%d$", new_uid(ctx))

                for m = ctx.modules; m.next != null; m = m.next {
                }
                m.next = mod

                define_module(ctx, stmt, asname, mod.abspath)

                curr_mod := ctx.current_module
                ctx.current_module = mod.abspath
                compile_file(ctx, stmt, mod.abspath)
                ctx.current_module = curr_mod
            } else {
                define_module(ctx, stmt, asname, mod.abspath)
            }
        }
    } else {
        io.printf(err_tmpl(ctx, stmt, "statement of type %s is not implemented"), stmt.type)
    }
}

chr* err_tmpl(types.CompilerCtx* ctx, parser.Node* stmt, chr* msg) {
    chr* buf
    io.asprintf(&buf, ":coffee-error: (%s: %d:%d) %s\n", ctx.current_module, stmt.line, stmt.char_of_line, msg)
    return buf
}

void compile_fn_params(types.CompilerCtx* ctx, parser.Node* fn_params) {
    types.Type* param_type
    for param_ptr := fn_params; param_ptr != null ; {
        if param_ptr != fn_params {
            param_ptr = param_ptr.next
        }

        param_info := new_assignable_info(fn_params)
        param_info.name_type = "variable"
        if string.strcmp(param_ptr.type, "type") == 0 {
            param_type = node_to_type(ctx, param_ptr.children)
            param_ptr = param_ptr.next
        }
        param_info.type = param_type

        var_name := param_ptr.value
        set_assignable_id(param_info, SCOPE_LOCAL, var_name)

        param_info_tr := lang_types.repr(ctx, param_info.type)
        io.fprintf(ctx.ir, "%s = alloca %s\n", repr_assignable_id(param_info), param_info_tr)
        define_assignable(ctx, param_ptr, var_name, param_info)
        io.fprintf(ctx.ir, "store %s %%.%s.arg, %s* %s\n", param_info_tr, var_name, param_info_tr, repr_assignable_id(param_info))
        param_ptr = param_ptr.next
    }
}


void compile_block(types.CompilerCtx* ctx, parser.Node* stmt) {
    push_scope(ctx, "block", (chr*) null, (chr*) null, (types.Type*) null)
    -- parse only expressions
    exprs := skip_to_type(stmt.children, "expressions")
    if exprs != null {
        for b := exprs.children; b != null ; b = b.next {
            compile_expression(ctx, b.children)
        }
    }
    pop_scope(ctx)
}

types.AssignableInfo* get_struct_attr(types.CompilerCtx* ctx, parser.Node* stmt, int attr_id) {
    val := compile_addr(ctx, stmt)
    if string.strcmp(val.type.container, "struct") != 0 {
        io.printf("WhAT!\n")
        return (types.AssignableInfo*) null
    }

    node_type := val.type.of
    for i := 0; i < attr_id; i = i + 1 {
        node_type = node_type.next
    }

    info := new_assignable_info(stmt)
    info.type = node_type

    tmp_id := new_uid(ctx)
    type_as_str := lang_types.repr(ctx, val.type)

    set_assignable_tmp_id(ctx, info)
    io.fprintf(ctx.ir, "%%.tmp%d = getelementptr %s, %s* %s, i32 0, i32 %d\n", tmp_id, type_as_str, type_as_str, repr_assignable_id(val), attr_id)
    io.fprintf(ctx.ir, "%s = load %s, %s* %%.tmp%d\n", repr_assignable_id(info), lang_types.repr(ctx, info.type), lang_types.repr(ctx, info.type), tmp_id)

    return info
}

void set_struct_attr(types.CompilerCtx* ctx, parser.Node* stmt, int attr_id, chr* attr) {
    val := compile_addr(ctx, stmt)
    if string.strcmp(val.type.container, "struct") != 0 {
        io.printf("WhAT!\n")
        return
    }

    node_type := val.type.of
    for i := 0; i < attr_id; i = i + 1 {
        node_type = node_type.next
    }

    tmp_id := new_uid(ctx)
    type_as_str := lang_types.repr(ctx, val.type)

    io.fprintf(ctx.ir, "%%.tmp%d = getelementptr %s, %s* %s, i32 0, i32 %d\n", tmp_id, type_as_str, type_as_str, repr_assignable_id(val), attr_id)
    io.fprintf(ctx.ir, "store %s, %s* %s\n", lang_types.repr(ctx, node_type), lang_types.repr(ctx, node_type), attr)
}


types.AssignableInfo* compile_builtin(types.CompilerCtx* ctx, parser.Node* stmt) {
    dotted := stmt.children.children
    if dotted.next != null {
        return (types.AssignableInfo*) null
    }

    if string.strcmp(dotted.value, "sizeof") == 0 {
        args := skip_to_type(stmt, "fn_args")
        value := skip_to_type(args.children, "assignable")
        value = value.children.children.children.children
        tmp_id := new_uid(ctx)

        info := new_assignable_info(stmt)
        set_assignable_tmp_id(ctx, info)

        info.type = new_type()
        info.type.container = "int"

        inspected_type := node_to_type(ctx, value)
        type_as_str := lang_types.repr(ctx, inspected_type)

        io.fprintf(ctx.ir, "%%.tmp%d = getelementptr %s, %s* null, i32 1\n", tmp_id, type_as_str, type_as_str)
        io.fprintf(ctx.ir, "%s = ptrtoint %s* %%.tmp%d to i32\n", repr_assignable_id(info), type_as_str, tmp_id)


        return info
    } elif string.strcmp(dotted.value, "append") == 0 {
        args := skip_to_type(stmt, "fn_args")

        array := skip_to_type(args.children, "assignable")
        value := skip_to_type(array.next, "assignable")

        value_info := compile_assignable(ctx, value)
        array_info := compile_addr(ctx, array)

        info := new_assignable_info(stmt)
        set_assignable_tmp_id(ctx, info)
        info.type = array_info.type

        chr* builtin_prefix
        io.asprintf(&builtin_prefix, ".b%d", new_uid(ctx))

        tmpl := builtin.append_tmpl()
        io.fprintf(ctx.ir, tmpl, builtin_prefix, lang_types.repr(ctx, array_info.type), repr_assignable_id(array_info), lang_types.repr(ctx, value_info.type), repr_assignable_id(value_info), repr_assignable_id(info))

        -- check if function is defined
        -- llvm_code := compile("extern chr* realloc(chr* pt, int size)")

        info_g := new_assignable_info(stmt)
        set_assignable_id(info_g, SCOPE_GLOBAL, "realloc")
        info_g.type = new_type()
        info_g.type.container = "function"

        -- return type
        info_g.type.of = new_type()
        info_g.type.of.container = "ptr"
        info_g.type.of.of = new_type()
        info_g.type.of.of.container = "chr"

        -- 1st argument
        info_g.type.of.next = new_type()
        info_g.type.of.next.container = "ptr"
        info_g.type.of.next.of = new_type()
        info_g.type.of.next.of.container = "chr"


        -- 2nd argument
        info_g.type.of.next.next = new_type()
        info_g.type.of.next.next.container = "int"

        define_global(ctx, "realloc", "extern", info_g, true, false)

        -- info.type = slice_dest.type
        return info
    } elif string.strcmp(dotted.value, "len") == 0 {
        args := skip_to_type(stmt, "fn_args")
        value := skip_to_type(args.children, "assignable")

        return get_struct_attr(ctx, value, 1)
    }

    return (types.AssignableInfo*) null
}

str resolve_import_path(types.CompilerCtx* ctx, parser.Node* stmt, str import_str) {
    err_buf := ""
    mod_abspath := ctx.current_module

    -- dirname to where import files from
    dirname := sys.dirname(mod_abspath)

    if import_str[0] == '/' {
        -- has tried to do an absolute import
        io.asprintf(&err_buf, "Imports %s must not start with '/' character.", import_str)
        new_error(ctx, stmt, err_buf)
        return (chr*) null
    }

    if import_str[0] != '.' & import_str[1] != '/' {
        -- it is not a relative import
        root := get_root()
        io.asprintf(&mod_abspath, "%s/lib/%s.bn", root, import_str)
    } elif string.strcmp(dirname, "") == 0 {
        --
        io.asprintf(&mod_abspath, "%s.bn", import_str)
    } else {
        io.asprintf(&mod_abspath, "%s/%s.bn", dirname, import_str)
    }
    return mod_abspath
}

types.AssignableInfo* compile_fn_call(types.CompilerCtx* ctx, parser.Node* stmt) {
    info := compile_builtin(ctx, stmt)
    if info != null {
        return info
    }
    info = compile_addr(ctx, stmt)
    if info == null {
        -- error
        if DEBUG_INTERNALS {
            io.printf(err_tmpl(ctx, stmt, "unable to compile function address"))
        }
        return (types.AssignableInfo*) null
    }

    args := skip_to_type(stmt, "fn_args")
    chr* params_buff = ""
    chr* tmp

    if string.strcmp(info.type.container, "ptr") == 0 {
        new_info := new_assignable_info(stmt)
        set_assignable_tmp_id(ctx, new_info)
        new_info.type = info.type.of

        io.fprintf(ctx.ir, "%s = load %s, %s* %s\n", repr_assignable_id(new_info), lang_types.repr(ctx, info.type), lang_types.repr(ctx, info.type), repr_assignable_id(info))

        info = new_info
    }

    if args != null {
        start := skip_to_type(args.children, "assignable")
        argno := 1
        expect_type := info.type.of.next

        provided_args := 0
        for pp := start; pp != null; pp = skip_to_type(pp.next, "assignable") {
            provided_args = provided_args + 1
        }


        for pp := start; pp != null; pp = skip_to_type(pp, "assignable") {
            if expect_type == null {
                io.asprintf(&tmp, "Function '%s' takes %d arguments, %d given", info.name, argno-1, provided_args)
                new_error(ctx, stmt, tmp)
                return (types.AssignableInfo*) null
            }

            if pp != start {
                io.asprintf(&tmp, "%s, ", params_buff)
                chr* tmp_buff = params_buff
                params_buff = tmp
                tmp = tmp_buff
                sys.free(tmp)
            }

            a_info := compile_assignable(ctx, pp)
            if a_info == null {
                return (types.AssignableInfo*) null
            }

            exp := type_clone(expect_type)
            exp.next = null

            if string.strcmp(expect_type.container, "vararg") != 0 & lang_types.cmp(ctx, a_info.type, exp) == false {
                err_buf := ""
                io.asprintf(&err_buf, "types.Type for argument %d does not match: '%s', got '%s'", argno, lang_types.repr(ctx, exp), lang_types.repr(ctx, a_info.type))
                new_error(ctx, pp, err_buf)
                return (types.AssignableInfo*) null
            }
            io.asprintf(&params_buff, "%s%s %s", params_buff, lang_types.repr(ctx, a_info.type), repr_assignable_id(a_info))
            pp = pp.next

            if string.strcmp(expect_type.container, "vararg") != 0 {
                expect_type = expect_type.next
            }
            argno = argno + 1
        }

        if expect_type != null {
            if string.strcmp(expect_type.container, "vararg") != 0 {
                io.asprintf(&tmp, "Function '%s' takes %d arguments, %d given", info.name, argno, provided_args)
                new_error(ctx, stmt, tmp)
                return (types.AssignableInfo*) null
            }
        }
    } elif info.type.of.next != null {

        args_required := 0
        for pp := info.type.of.next; pp != null; pp = pp.next {
            if string.strcmp(pp.container, "vararg") == 0 {
                break
            }
            args_required = args_required + 1
        } else {
            io.asprintf(&tmp, "Function '%s' takes %d arguments, 0 given", info.name, args_required)
            new_error(ctx, stmt, tmp)
            return (types.AssignableInfo*) null
        }
    }


    if string.strcmp(lang_types.repr(ctx, info.type.of), "void") == 0 {
        io.fprintf(ctx.ir, "call %s %s(%s)\n", lang_types.repr(ctx, info.type), repr_assignable_id(info), params_buff)
        return (types.AssignableInfo*) null
    }

    call_info := new_assignable_info(stmt)
    set_assignable_tmp_id(ctx, call_info)
    call_info.type = type_clone(info.type.of)
    call_info.type.next = null

    io.fprintf(ctx.ir, "%s = call %s %s(%s)\n", repr_assignable_id(call_info), lang_types.repr(ctx, info.type), repr_assignable_id(info), params_buff)

    return (types.AssignableInfo*) call_info
}

void compile_expression(types.CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg
    expr_type := stmt.type

    types.AssignableInfo* info = (types.AssignableInfo*) null
    parser.Node* assignable
    types.AssignableInfo* a_info = (types.AssignableInfo*) null

    if string.strcmp(expr_type, "return") == 0 {
        fn_scope := get_scope(ctx, "function")
        if fn_scope == null {
            new_error(ctx, stmt, "'return' used outside of function scope")
            return
        }

        if string.strcmp(stmt.children.next.type, "NL") != 0 {
            info = compile_assignable(ctx, stmt.children.next)
            if info == null {
                return
            }
            if lang_types.cmp(ctx, info.type, fn_scope.return_type) == false {
                buf := ""
                io.asprintf(&buf, "trying to return '%s' from function declared with return type '%s'", lang_types.repr(ctx, info.type), lang_types.repr(ctx, fn_scope.return_type))
                new_error(ctx, stmt, buf)
                return
            }

            io.fprintf(ctx.ir, "ret %s %s\n", lang_types.repr(ctx, info.type), repr_assignable_id(info))

        } else {
            io.fprintf(ctx.ir, "ret void\n")
        }

    } elif string.strcmp(expr_type, "NL") == 0 {
        -- skip empty newlines
    } elif string.strcmp(expr_type, "fn_call") == 0 {
        compile_fn_call(ctx, stmt.children)
    } elif string.strcmp(expr_type, "declaration") == 0 {
        compile_declaration(ctx, stmt)
    } elif string.strcmp(expr_type, "assignment") == 0 {
        assignable = skip_to_type(stmt.children, "assignable")
        dest := compile_addr(ctx, stmt.children)
        if dest == null {
            return
        }
        a_info = compile_assignable(ctx, assignable)
        if a_info == null {
            return
        }
        if lang_types.cmp(ctx, a_info.type, dest.type) == false {
            err_buf := ""
            io.asprintf(&err_buf, "cannot assign type '%s' to type '%s'", lang_types.repr(ctx, a_info.type), lang_types.repr(ctx, dest.type))
            new_error(ctx, stmt, err_buf)
        }

        dest_tr := lang_types.repr(ctx, dest.type)
        chr* src_tr = lang_types.repr(ctx, a_info.type)
        if string.strcmp(src_tr, "ptr") == 0 {
            src_tr = dest_tr
        }
        io.fprintf(ctx.ir, "store %s %s, %s* %s\n", src_tr, repr_assignable_id(a_info), dest_tr, repr_assignable_id(dest))
    } elif string.strcmp(expr_type, "if_block") == 0 {
        compile_if_block(ctx, stmt)
    } elif string.strcmp(expr_type, "for_loop") == 0 {
        compile_for_loop(ctx, stmt)
    } elif string.strcmp(expr_type, "keyword") == 0 {

        for_scope := get_scope(ctx, "for")
        if for_scope == null {
            buf := ""
            io.asprintf(&buf, "'%s' keyword used outside 'for' statement", stmt.children.value)
            new_error(ctx, stmt, buf)
            return
        }

        if string.strcmp(stmt.children.value, "break") == 0 {
            io.fprintf(ctx.ir, "br label %%%s\n", for_scope.end_id)

        } elif string.strcmp(stmt.children.value, "continue") == 0 {
            io.fprintf(ctx.ir, "br label %%%s\n", for_scope.begin_id)
        }
    } elif string.strcmp(expr_type, "function") == 0 {
        compile_closure(ctx, stmt)
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to compile expression '%s'"), expr_type)
    }
}

types.Scope* get_scope(types.CompilerCtx* ctx, str scope_type) {
    mod := get_current_module(ctx)
    for s := mod.scopes; s != null; s = s.prev {
        if string.strcmp(s.type, scope_type) == 0 {
            return s
        }
    }
    return (types.Scope*) null
}

types.Type* type_ptr_of_chr() {
    t := new_type()
    t.container = "ptr"
    t.of = new_type()
    t.of.container = "chr"
    return t
}


void compile_closure(types.CompilerCtx* ctx, parser.Node* stmt) {
    cj_id := new_uid(ctx)

    -- define requied weak globals
    -- llvm.init.trampoline
    info_lit := new_assignable_info(stmt)
    set_assignable_id(info_lit, SCOPE_GLOBAL, "llvm.init.trampoline")
    info_lit.type = new_type()
    info_lit.type.container = "function"
    info_lit.type.of = new_type()
    info_lit.type.of.container = "void"
    info_lit.type.of.next = type_ptr_of_chr()
    info_lit.type.of.next.next = type_ptr_of_chr()
    info_lit.type.of.next.next.next = type_ptr_of_chr()
    define_global(ctx, "llvm.init.trampoline", "extern", info_lit, true, false)

    -- @llvm.adjust.trampoline
    info_lat := new_assignable_info(stmt)
    set_assignable_id(info_lat, SCOPE_GLOBAL, "llvm.adjust.trampoline")
    info_lat.type = new_type()
    info_lat.type.container = "function"
    info_lat.type.of = type_ptr_of_chr()
    info_lat.type.of.next = type_ptr_of_chr()
    define_global(ctx, "llvm.adjust.trampoline", "extern", info_lat, true, false)

    -- mmap
    info_mmap := new_assignable_info(stmt)
    set_assignable_id(info_mmap, SCOPE_GLOBAL, "mmap")
    info_mmap.type = new_type()
    info_mmap.type.container = "function"
    info_mmap.type.of = type_ptr_of_chr()
    lt := info_mmap.type.of
    lt.next = type_ptr_of_chr()
    lt = lt.next
    lt.next = new_type()
    lt.next.container = "int"
    lt = lt.next
    lt.next = new_type()
    lt.next.container = "int"
    lt = lt.next
    lt.next = new_type()
    lt.next.container = "int"
    lt = lt.next
    lt.next = new_type()
    lt.next.container = "int"
    lt = lt.next
    lt.next = new_type()
    lt.next.container = "int"
    lt = lt.next

    define_global(ctx, "mmap", "extern", info_mmap, true, false)



    fn_name_node := skip_to_type(stmt.children, "WORD")
    fn_name := fn_name_node.value

    info := new_assignable_info(stmt)
    set_assignable_id(info, SCOPE_LOCAL, fn_name)
    info.type = syn_function_type(ctx, stmt.children)
    info.name_type = "function"

    define_assignable(ctx, stmt, fn_name, info)

    closure_id := new_uid(ctx)

    closure_type := type_clone(info.type)
    closure_type.of = type_clone(closure_type.of)

    ctx_param := new_type()
    ctx_param.container = "ptr"
    ctx_param.of = new_type()
    ctx_param.of.container = "struct"
    ctx_param.next = closure_type.of.next
    closure_type.of.next = ctx_param

    closure_name := ""
    io.asprintf(&closure_name, "@.%d", closure_id)

    ret_type := type_clone(closure_type.of)
    ret_type.of = null

    io.fprintf(ctx.ir, "%%.tmem%d = call i8*(i8*,i32,i32,i32,i32,i32) @mmap(i8* null, i32 72, i32 7, i32 34, i32 -1, i32 0)\n", closure_id)
    io.fprintf(ctx.ir, "call void(i8*,i8*,i8*) @llvm.init.trampoline(i8* %%.tmem%d, i8* bitcast (%s* %s to i8*), i8* null)\n", closure_id, lang_types.repr(ctx, closure_type), closure_name)
    io.fprintf(ctx.ir, "%%.trmp%d = call i8*(i8*) @llvm.adjust.trampoline(i8* %%.tmem%d)\n", closure_id, closure_id)
    io.fprintf(ctx.ir, "%s = bitcast i8* %%.trmp%d to %s*\n", repr_assignable_id(info), closure_id, lang_types.repr(ctx, info.type))

    bkp_ctx := ctx.ir
    ctx.ir = io.tmpfile()
    io.fprintf(ctx.ir, "define %s %s(", lang_types.repr(ctx, ret_type), closure_name)
    -- define params
    push_scope(ctx, "function", (chr*) null, (chr*) null, ret_type)
    io.fprintf(ctx.ir, "%s nest %%.0", lang_types.repr(ctx, ctx_param))
    params := syn_function_params(stmt.children)
    types.Type* param_type
    for param_ptr := params; param_ptr != null ; {
        if param_ptr != params {
            param_ptr = param_ptr.next
        }
        io.fprintf(ctx.ir, ", ")
        if string.strcmp(param_ptr.type, "type") == 0 {
            param_type = node_to_type(ctx, param_ptr.children)
            param_ptr = param_ptr.next
        }
        io.fprintf(ctx.ir, "%s %%.%s.arg", lang_types.repr(ctx, param_type), param_ptr.value)
        param_ptr = param_ptr.next
    }
    io.fprintf(ctx.ir, ") {\n")
    compile_fn_params(ctx, params)
    block := skip_to_type(stmt.children, "block")
    compile_block(ctx, block)
    check_n_add_implicit_return(ctx, block, ret_type)
    pop_scope(ctx)
    io.fprintf(ctx.ir, "}\n")

    io.rewind(ctx.ir)
    code := ioutil.readall(io.fileno(ctx.ir))
    io.fclose(ctx.ir)
    ctx.ir = bkp_ctx

    append_anon_fn(ctx, code)

    -- captured_params := ""

    -- io.fprintf(ctx.ir, "define %s @.cj.%d(%s nest %%.0) {", lang_types.repr(ctx, rv), cj_id)
    -- io.fprintf(ctx.ir, "}")
}

void check_n_add_implicit_return(types.CompilerCtx* ctx, parser.Node* stmt, types.Type* return_type) {
    li := (parser.Node*) null

    exprs := skip_to_type(stmt.children, "expressions")
    for ci := exprs.children; ci != null; ci = ci.next {
        -- valid instructions are empty new lines and... OPERATOR?
        if string.strcmp(ci.type, "NL") != 0 {
            li = ci
        }
    }

    if li != null {
        if string.strcmp(li.children.type, "return") == 0 {
            return
        }
    }

    if string.strcmp(lang_types.repr(ctx, return_type), "void") != 0 {
        if li != null {
            stmt = li
        }
        new_error(ctx, stmt, "Missing return value")
    } else {
        io.fprintf(ctx.ir, "ret void\n")
    }
}

void compile_for_loop(types.CompilerCtx* ctx, parser.Node* stmt) {
    for_id := new_uid(ctx)
    init_stmt := stmt.children.next
    chr* begin_lbl = (chr*) null
    chr* end_lbl = (chr*) null

    io.asprintf(&begin_lbl, ".for.start.%d", for_id)
    io.asprintf(&end_lbl, ".for.end.%d", for_id)

    push_scope(ctx, "for", begin_lbl, end_lbl, (types.Type*) null)

    if string.strcmp(init_stmt.type, "declaration") == 0 {
        compile_declaration(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "assignment") == 0 {
        compile_expression(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "OPERATOR") == 0 {
        -- no init condition provided
    } else {
        -- coffee error
        io.printf(err_tmpl(ctx, init_stmt, "unable to compile statement of type %s in for loop init condition"), init_stmt.type)
        pop_scope(ctx)
        return
    }

    io.fprintf(ctx.ir, "br label %%.for.start.%d\n", for_id)
    io.fprintf(ctx.ir, ".for.start.%d:\n", for_id)

    -- check for 'for' condition
    fst_colon := skip_to_type(stmt.children, "OPERATOR")
    condition := fst_colon.next
    if string.strcmp(condition.type, "OPERATOR") == 0 {
        new_error(ctx, condition, "Expecting boolean condition, found ';'")
        return
    }
    condition_info := compile_assignable(ctx, condition)
    snd_colon := skip_to_type(fst_colon.next, "OPERATOR")
    for_body := skip_to_type(snd_colon, "block")
    else_block := skip_to_type(for_body, "else_block")

    on_end := end_lbl
    if else_block != null {
        io.asprintf(&on_end, ".for.else.%d", for_id)
    }

    io.fprintf(ctx.ir, "br %s %s, label %%.for.continue.%d, label %%%s\n", lang_types.repr(ctx, condition_info.type), repr_assignable_id(condition_info), for_id, on_end)

    io.fprintf(ctx.ir, ".for.continue.%d:\n", for_id)

    -- compile body

    increment := snd_colon.next

    compile_block(ctx, for_body)


    -- compile increment statement only if it exists
    if increment != for_body {
        compile_expression(ctx, increment)
    }

    -- execute for increment before next loop
    io.fprintf(ctx.ir, "br label %%%s\n", begin_lbl)
    -- compile else
    if else_block != null {
        io.fprintf(ctx.ir, ".for.else.%d:\n", for_id)
        block := skip_to_type(else_block.children, "block")
        compile_block(ctx, block)
        io.fprintf(ctx.ir, "br label %%%s\n", end_lbl)
    }
    io.fprintf(ctx.ir, "%s:\n", end_lbl)
    pop_scope(ctx)
}

types.AssignableInfo* compile_declaration(types.CompilerCtx* ctx, parser.Node* stmt) {
    types.Type* decl_type = (types.Type*) null
    types.AssignableInfo* a_info = (types.AssignableInfo*) null

    -- explicit declaration: detect variable type from starting 'type' node
    if string.strcmp(stmt.children.type, "type") == 0 {
        decl_type = node_to_type(ctx, stmt.children.children)
    }

    assignable := skip_to_type(stmt.children, "assignable")

    if assignable != null {
        a_info = compile_assignable(ctx, assignable)
    }

    info := new_assignable_info(stmt)
    info.name_type = "variable"
    var_name := skip_to_type(stmt.children, "WORD")

    if var_name == null {
        io.printf(err_tmpl(ctx, stmt, "unable to get declaration name"))
        return (types.AssignableInfo*) null
    }

    mod := get_current_module(ctx)
    if find_defined_here(ctx, mod.scopes, var_name.value) != null {
        chr* err_buf
        io.asprintf(&err_buf, "Name '%s' is already defined in this scope", var_name.value)
        new_error(ctx, stmt, err_buf)
        return (types.AssignableInfo*) null
    }

    chr* var_id
    io.asprintf(&var_id, "%s.%d", var_name.value, new_uid(ctx))
    set_assignable_id(info, SCOPE_LOCAL, var_id)

    if decl_type != null {
        info.type = decl_type
    } elif a_info != null {
        info.type = a_info.type
    }
    var_type_repr := lang_types.repr(ctx, info.type)
    if a_info != null {
        a_type_repr := lang_types.repr(ctx, a_info.type)
        if lang_types.cmp(ctx, a_info.type, info.type) == false {
            chr* err_msg = (chr*) null
            io.asprintf(&err_msg, "cannot assign type '%s' to variable of type '%s'", a_type_repr, var_type_repr)
            new_error(ctx, stmt, err_msg)
        }
    }
    define_assignable(ctx, stmt, var_name.value, info)

    io.fprintf(ctx.ir, "%s = alloca %s\n", repr_assignable_id(info), var_type_repr)
    if a_info != null {
        io.fprintf(ctx.ir, "store %s %s, %s* %s\n", lang_types.repr(ctx, a_info.type), repr_assignable_id(a_info), var_type_repr, repr_assignable_id(info))
    } else {
        -- auto-initialization of type
        compile_zero_value(ctx, stmt, info)
    }
    return info
}

void compile_zero_value(types.CompilerCtx* ctx, parser.Node* stmt, types.AssignableInfo* info) {
    if info.type == null {
        return
    }
    t_repr := lang_types.repr(ctx, info.type)
    id := repr_assignable_id(info)
    field_id := 0
    types.Type* field
    types.AssignableInfo* field_info

    t := info.type
    if string.strcmp(t.container, "int") == 0 | string.strcmp(t.container, "chr") == 0 | string.strcmp(t.container, "bool") == 0 {
        io.fprintf(ctx.ir, "store %s %d, %s* %s\n", t_repr, 0, t_repr, id)
    } elif string.strcmp(t.container, "ptr") == 0 {
        io.fprintf(ctx.ir, "store %s %s, %s* %s\n", t_repr, "null", t_repr, id)
    } elif string.strcmp(t.container, "struct") == 0 {
        for field = t.of; field != null; field = field.next {
            field_info = new_assignable_info(stmt)
            set_assignable_tmp_id(ctx, field_info)
            field_info.type = field

            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\n", repr_assignable_id(field_info), t_repr, t_repr, id, field_id)
            compile_zero_value(ctx, stmt, field_info)
            field_id = field_id + 1
        }
    } elif string.strcmp(t.container, "typealias") == 0 {
        for field = t.of.of; field != null; field = field.next {
            field_info = new_assignable_info(stmt)
            set_assignable_tmp_id(ctx, field_info)
            field_info.type = field

            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\n", repr_assignable_id(field_info), t_repr, t_repr, id, field_id)
            compile_zero_value(ctx, stmt, field_info)
            field_id = field_id + 1
        }
    } else {
        io.printf(err_tmpl(ctx, stmt, "Default type not existent for type: %s (%s)"), info.type.container, lang_types.repr(ctx, info.type))
        return
    }
}

void compile_if_block(types.CompilerCtx* ctx, parser.Node* stmt) {

    assignable := skip_to_type(stmt.children, "assignable")
    a_info := compile_assignable(ctx, assignable)
    if a_info == null {
        return
    }

    if_id := new_uid(ctx)
    io.fprintf(ctx.ir, "br %s %s, label %%.if.true.%d, label %%.if.false.%d\n", lang_types.repr(ctx, a_info.type), repr_assignable_id(a_info), if_id, if_id)
    io.fprintf(ctx.ir, ".if.true.%d:\n", if_id)
    block := skip_to_type(stmt.children, "block")
    compile_block(ctx, block)
    io.fprintf(ctx.ir, "br label %%.if.end.%d\n", if_id)
    io.fprintf(ctx.ir, ".if.false.%d:\n", if_id)

    else_block := skip_to_type(stmt.children, "elif_block")
    if else_block != null {
        if string.strcmp(else_block.children.type, "else_block") == 0 {
            block = skip_to_type(else_block.children.children, "block")
            compile_block(ctx, block)
        } else {
            compile_if_block(ctx, else_block)
        }
    }

    -- compile any elif blocks
    io.fprintf(ctx.ir, "br label %%.if.end.%d\n", if_id)
    io.fprintf(ctx.ir, ".if.end.%d:\n", if_id)
}


void new_error(types.CompilerCtx* ctx, parser.Node* curr_node, str msg) {
    if curr_node != null {
        err := errors.new(ctx.current_module, curr_node.line, curr_node.char_of_line, msg)
        append_error(ctx, err)
    } else {
        sys.assert(false, "Programming error, unable to create new error from null node")
    }
}


-- binds the assignable to a given name in the current scope
void define_assignable(types.CompilerCtx* ctx, parser.Node* stmt, str name, types.AssignableInfo* info) {
    mod := get_current_module(ctx)
    sys.assert(mod.scopes != null, ":coffee-error: 'define_assignable' could not be called if context scopes are null")
    current_scope := mod.scopes

    newitem := (types.ScopeItem*) sys.malloc(sizeof(types.ScopeItem))
    newitem.name = name
    newitem.info = info
    newitem.next = null
    info.name = name


    if current_scope.item == null {
        current_scope.item = newitem
        return
    }


    last_item := current_scope.item
    err_buf := ""
    if string.strcmp(last_item.name, name) == 0 {
        io.asprintf(&err_buf, "Name '%s' is already defined in this scope", name)
        new_error(ctx, stmt, err_buf)
    }

    for ; last_item.next != null; last_item = last_item.next {
        if string.strcmp(last_item.name, name) == 0 {
            io.asprintf(&err_buf, "Name '%s' is already defined in this scope", name)
            new_error(ctx, stmt, err_buf)
            break
        }
    } else {
        last_item.next = newitem
    }
}

types.ScopeItem* find_defined_in(types.CompilerCtx* ctx, str module, parser.Node* dotted_name) {
    chr* err_buf

    found := find_defined_str(ctx, module, dotted_name.value)
    if found == null {
        -- io.asprintf(&err_buf, "Name %s not found in module %s", dotted_name.value, module)
        -- new_error(ctx, dotted_name, err_buf)
        return (types.ScopeItem*) null
    }

    for ; dotted_name.next != null & string.strcmp(found.info.name_type, "module") == 0 ; {
        found = find_defined_in(ctx, found.info.id, dotted_name.next.next)

        if found == null {
            return (types.ScopeItem*) null
        }
    }

    return found
}

types.ScopeItem* find_defined_here(types.CompilerCtx* ctx, types.Scope* s, str name) {
    if s == null {
        return (types.ScopeItem*) null
    }

    for item := s.item; item != null; item = item.next {
        if string.strcmp(item.name, name) == 0 {
            return item
        }
    }
    return (types.ScopeItem*) null
}


types.ScopeItem* find_defined_str(types.CompilerCtx* ctx, str module, str assignable_name) {
    mod := get_module(ctx, module)
    sys.assert(mod.scopes != null, ":coffee-error: 'find_defined' could not be called if context scopes are null")


    for s := mod.scopes; s != null; s = s.prev {
        item := find_defined_here(ctx, s, assignable_name)
        if item != null {
            return item
        }
    }

    return (types.ScopeItem*) null
}

-- returns the 'base' information of the dotted name
types.ScopeItem* find_defined(types.CompilerCtx* ctx, parser.Node* dotted_name) {
    return find_defined_in(ctx, ctx.current_module, dotted_name.children)
}


types.AssignableInfo* get_dotted_name(types.CompilerCtx* ctx, parser.Node* dot_name_ptr, types.AssignableInfo* info) {
    chr* err_msg
    chr* buf

    if info == null {
        io.printf(err_tmpl(ctx, dot_name_ptr, "cannot call 'get_dotted_name' on null assignable info"))
        return (types.AssignableInfo*) null
    }

    if string.strcmp(info.name_type, "function") == 0 | string.strcmp(info.name_type, "extern") == 0 {
        -- got a function, cannot read dot names anymore
        if dot_name_ptr.next != null {
            io.asprintf(&err_msg, "cannot get attribute %s from function type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (types.AssignableInfo*) null
        }
        return info
    } elif string.strcmp(info.name_type, "variable") == 0 & dot_name_ptr.next != null {
        base_var := info

        struct_info := base_var.type

        -- auto-dereference variable
        for ; string.strcmp(base_var.type.container, "ptr") == 0 ; {
            new_base := new_assignable_info(dot_name_ptr)
            set_assignable_tmp_id(ctx, new_base)
            new_base.type = base_var.type.of

            io.fprintf(ctx.ir, "%s = load %s*, %s* %s\n", repr_assignable_id(new_base), lang_types.repr(ctx, new_base.type), lang_types.repr(ctx, base_var.type), repr_assignable_id(base_var))
            base_var = new_base

            struct_info = struct_info.of
        }

        if string.strcmp(struct_info.container, "typealias") == 0 {
            struct_info = struct_info.of
        }

        if string.strcmp(struct_info.container, "struct") != 0 {
            io.asprintf(&err_msg, "cannot get attribute %s from non struct type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (types.AssignableInfo*) null
        }

        field_name := dot_name_ptr.next.next.value

        -- struct
        field_id := 0
        found_field := (types.Type*) null

        -- here, from a struct i'm extracting the value of the field.
        for field := struct_info.of; field != null; field = field.next {
            if string.strcmp(field.info, field_name) == 0 {
                found_field = field
                break
            } else {
                field_id = field_id + 1
            }
        }

        if found_field == null {
            io.asprintf(&err_msg, "field %s not defined in struct %s", field_name, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (types.AssignableInfo*) null
        }

        new_info := new_assignable_info(dot_name_ptr)
        new_info.type = found_field

        set_assignable_tmp_id(ctx, new_info)
        new_info.name_type = "variable"

        info_tr := lang_types.repr(ctx, base_var.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\n", repr_assignable_id(new_info), info_tr, info_tr, repr_assignable_id(base_var), field_id)

        return get_dotted_name(ctx, dot_name_ptr.next.next, new_info)

    } elif string.strcmp(info.name_type, "variable") == 0 {
        return info
    }

    io.printf(err_tmpl(ctx, dot_name_ptr, "`get_dotted_name` does not handle type: %s"), info.name_type)
    return (types.AssignableInfo*) null
}

-- returns address for node
types.AssignableInfo* compile_addr(types.CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg

    curr_node := stmt
    if string.strcmp(curr_node.type, "addr_destination") == 0 | string.strcmp(curr_node.type, "mono_assignable") == 0 | string.strcmp(curr_node.type, "assignable") == 0 {
        return compile_addr(ctx, stmt.children)
    }
    if string.strcmp(curr_node.type, "destination") != 0 {
        io.printf(":coffee-error: 'compile_addr' could only be called on destinations for now. (called on %s)\n", curr_node.type)
        -- return (types.AssignableInfo*) null
        curr_node = stmt.children
    }
    -- extract the destination

    -- type + id of addr
    assignable_name := curr_node.children
    scope_info := find_defined_str(ctx, ctx.current_module, assignable_name.children.value)
    if scope_info == null {
        -- error! name is not defined
        io.asprintf(&err_msg, "name '%s' was not declared in this scope", assignable_name.children.value)
        new_error(ctx, assignable_name, err_msg)
        return (types.AssignableInfo*) null
    }
    info := scope_info.info

    if string.strcmp(info.name_type, "module") == 0 {
        scope_info = find_defined_str(ctx, repr_assignable_id(info), assignable_name.children.next.next.value)
        if scope_info == null {
            io.asprintf(&err_msg, "name '%s' is not defined in %s", assignable_name.children.next.next.value, repr_assignable_id(info))
            new_error(ctx, curr_node, err_msg)
            return (types.AssignableInfo*) null
        }
        info = scope_info.info
        assignable_name = assignable_name.children.next.next
    } else {
        assignable_name = assignable_name.children
    }

    base := get_dotted_name(ctx, assignable_name, info)

    -- node has a following square bracket, do something

    for addr := curr_node.children.next; addr != null; addr = addr.next.next.next {
        index := addr.next
        index_info := compile_assignable(ctx, index)

        index_type := lang_types.repr(ctx, index_info.type)

        -- automatically get correct index from slice
        if base.type.info != null {
            if string.strcmp(base.type.info , "slice") == 0 {
                new_base := new_assignable_info(curr_node)
                set_assignable_tmp_id(ctx, new_base)

                io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 0\n", repr_assignable_id(new_base), lang_types.repr(ctx, base.type), lang_types.repr(ctx, base.type), repr_assignable_id(base))

                new_base.type = type_clone(base.type.of)
                new_base.type.next = null
                base = new_base
            }
        }

        base_type := lang_types.repr(ctx, base.type)

        tmp_id := new_uid(ctx)
        io.fprintf(ctx.ir, "%%.tmp%d = load %s, %s* %s\n", tmp_id, base_type, base_type, repr_assignable_id(base))

        new_base := new_assignable_info(curr_node)
        set_assignable_tmp_id(ctx, new_base)

        if base.type.of == null {
            io.asprintf(&err_msg, "Unable to get address for type: %s", base_type)
            new_error(ctx, addr, err_msg)
            return base
        }

        new_base.type = base.type.of
        base_type_2 := lang_types.repr(ctx, new_base.type)

        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %%.tmp%d, %s %s\n", repr_assignable_id(new_base), base_type_2, base_type_2, tmp_id, index_type, repr_assignable_id(index_info))

        base = new_base
    }

    -- extract address if it's a destination
    return base
}


alias StackHead = struct {
    sy.SYStack* h,
}

types.AssignableInfo* compile_assignable(types.CompilerCtx* ctx, parser.Node* curr_node) {
    assignable_start := skip_to_type(curr_node.children, "mono_assignable")
    operator_stack := sy.sy_algorithm(assignable_start)

    stack := (StackHead*) sys.malloc(sizeof(StackHead))
    stack.h = operator_stack

    info := compile_assignable_stack(ctx, stack)
    if info == null {
        return info
    }

    cast := skip_to_type(curr_node.children, "cast")
    if cast != null {
        cast_type := skip_to_type(cast.children, "type")

        type := node_to_type(ctx, cast_type.children)
        -- chr* new_id
        -- io.asprintf(&new_id, "%%.tmp%d", new_uid(ctx))
        prev_id := repr_assignable_id(info)
        set_assignable_tmp_id(ctx, info)

        from_type := lang_types.repr(ctx, info.type)
        to_type := lang_types.repr(ctx, type)

        cast_fn := "bitcast"
        if info.type.info != null {
            if string.strcmp(info.type.info, "slice") == 0 {
                io.printf("Casting array to slices is not implemented yet\n")
            }
        }

        if string.strcmp(info.type.container, "ptr") != 0 & string.strcmp(type.container, "ptr") != 0 {
            if from_type[0] == 'i' & to_type[0] == 'i' {
                int from_size
                int to_size
                io.sscanf(from_type, "i%d", &from_size)
                io.sscanf(to_type, "i%d", &to_size)

                if from_size < to_size {
                    cast_fn = "sext"
                } else {
                    cast_fn = "trunc"
                }
            }
        }

        io.fprintf(ctx.ir, "%s = %s %s %s to %s\n", repr_assignable_id(info), cast_fn, from_type, prev_id, to_type)

        info.type = type
    }
    return info
}

types.AssignableInfo* compile_assignable_stack(types.CompilerCtx* ctx, StackHead* stack) {
    if string.strcmp(stack.h.n.type, "mono_assignable") == 0 {
        return compile_mono_assignable(ctx, stack.h.n)
    }
    operator := stack.h.n.children

    stack.h = stack.h.prev
    A := compile_assignable_stack(ctx, stack)

    if A == null {
        return A
    }

    stack.h = stack.h.prev
    B := compile_assignable_stack(ctx, stack)
    if B == null {
        return B
    }

    op_info := new_assignable_info((parser.Node*) null)
    op_info.type = operator_type(operator)

    -- op_id := new_uid(ctx)
    set_assignable_tmp_id(ctx, op_info)
    io.fprintf(ctx.ir, "%s = %s %s %s, %s\n", repr_assignable_id(op_info), operator_op(ctx, operator), lang_types.repr(ctx, A.type), repr_assignable_id(A), repr_assignable_id(B))

    return op_info
}

str operator_op(types.CompilerCtx* ctx, parser.Node* op) {
    if op == null {
        io.printf(err_tmpl(ctx, op, "called 'operator_op' with null"))
    }

    if string.strcmp(op.value, "+") == 0 {
        return "add"
    } elif string.strcmp(op.value, "-") == 0 {
        return "sub"
    } elif string.strcmp(op.value, "*") == 0 {
        return "mul"
    } elif string.strcmp(op.value, "/") == 0 {
        return "sdiv"
    } elif string.strcmp(op.value, "==") == 0 {
        return "icmp eq"
    } elif string.strcmp(op.value, "!=") == 0 {
        return "icmp ne"
    } elif string.strcmp(op.value, ">") == 0 {
        return "icmp sgt"
    } elif string.strcmp(op.value, "<") == 0 {
        return "icmp slt"
    } elif string.strcmp(op.value, "&") == 0 {
        return "and"
    } elif string.strcmp(op.value, "|") == 0 {
        return "or"
    } elif string.strcmp(op.value, ">=") == 0 {
        return "icmp sge"
    } elif string.strcmp(op.value, "<=") == 0 {
        return "icmp sle"
    } elif string.strcmp(op.value, "%") == 0 {
        return "srem"
    } else {
        io.printf(err_tmpl(ctx, op, "operator '%s' not implemented"), op.value)
    }
    return "add"
}

types.Type* operator_type(parser.Node* op) {
    type := new_type()
    if string.strcmp(op.value, "==") == 0 | string.strcmp(op.value, "!=") == 0 | string.strcmp(op.value, "|") == 0 | string.strcmp(op.value, "&") == 0 | string.strcmp(op.value, ">") == 0 | string.strcmp(op.value, "<") == 0 | string.strcmp(op.value, ">=") == 0 | string.strcmp(op.value, "<=") == 0 {
        type.container = "bool"
    } else {
        type.container = "int"
    }
    return type
}

types.AssignableInfo* compile_mono_assignable(types.CompilerCtx* ctx, parser.Node* curr_node) {
    types.AssignableInfo* assignable_info = (types.AssignableInfo*) null
    mono := curr_node
    chr* err_buf
    chr* buf

    if string.strcmp(mono.children.type, "NUMBER") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = new_type()
        assignable_info.type.container = "int"
        set_assignable_id(assignable_info, SCOPE_CONST, mono.children.value)

    } elif string.strcmp(mono.children.type, "WORD") == 0 {
        if string.strcmp(mono.children.value, "null") != 0 {
            io.printf(err_tmpl(ctx, curr_node, "unable to interpret %s as mono_assignable"), mono.children.value)
            return (types.AssignableInfo*) null
        }
        assignable_info = new_assignable_info(curr_node)
        set_assignable_id(assignable_info, SCOPE_CONST, "null")
        assignable_info.type = new_type()
        assignable_info.type.container = "nullptr"

    } elif string.strcmp(mono.children.type, "addr_destination") == 0 {
        assignable_info = new_assignable_info(curr_node)
        dest := skip_to_type(mono.children.children, "destination")
        var_info := compile_addr(ctx, dest)

        if var_info == null {
            return (types.AssignableInfo*) null
        }

        var_type_repr := lang_types.repr(ctx, var_info.type)
        set_assignable_tmp_id(ctx, assignable_info)

        assignable_info.type = var_info.type
        for ptr := mono.children.children; ptr != dest; ptr = ptr.next {
            type := new_type()
            type.of = assignable_info.type
            type.container = "ptr"

            assignable_info.type = type
        }

        if mono.children.children != dest {
            -- it's a pointer, load it's address
            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0\n", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        } elif string.strcmp(assignable_info.type.container, "function") == 0 {
            assignable_info = var_info
            type := new_type()
            type.of = assignable_info.type
            type.container = "ptr"
            assignable_info.type = type
        } else {
            -- it's a variable, load it's content
            io.fprintf(ctx.ir, "%s = load %s, %s* %s\n", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        }

    } elif string.strcmp(mono.children.type, "boolean") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = new_type()
        assignable_info.type.container = "bool"
        if string.strcmp(mono.children.children.value, "false") == 0 {
            set_assignable_id(assignable_info, SCOPE_CONST, "0")
        } else {
            set_assignable_id(assignable_info, SCOPE_CONST, "1")
        }
    } elif string.strcmp(mono.children.type, "fn_call") == 0 {
        assignable_info = compile_fn_call(ctx, mono.children.children)
    } elif string.strcmp(mono.children.type, "STRING") == 0 {
        string_info := define_string(ctx, mono.children.value) -- defines strings for future reuse, plus defines global functions or data structures when used
        assignable_info = new_assignable_info(curr_node)
        set_assignable_tmp_id(ctx, assignable_info)

        str_tr := lang_types.repr(ctx, string_info.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s*%s, i32 0, i32 0\n", repr_assignable_id(assignable_info), str_tr, str_tr, repr_assignable_id(string_info))

        assignable_info.type = new_type()
        assignable_info.type.container = "ptr"
        assignable_info.type.of = new_type()
        assignable_info.type.of.container = "chr"

    } elif string.strcmp(mono.children.type, "CHR") == 0 {
        assignable_info = new_assignable_info(curr_node)
        chr_len := string.strlen(mono.children.value)
        set_assignable_id(assignable_info, SCOPE_CONST, "0")

        assignable_info.id = llvm.chr_to_llvm(mono.children.value)
        if assignable_info.id == null {
            io.asprintf(&err_buf, "Invalid character: %s", mono.children.value)
            return (types.AssignableInfo*) null
        }
        assignable_info.type = new_type()
        assignable_info.type.container = "chr"
    } else {
        io.printf(err_tmpl(ctx, mono, "unable to compile assignable of type %s"), mono.children.type)
        return (types.AssignableInfo*) null
    }

    if assignable_info == null {
        return (types.AssignableInfo*) null
    }
    assignable_info.line = curr_node.line
    assignable_info.char_of_line = curr_node.char_of_line
    return (types.AssignableInfo*) assignable_info
}

str type_abbr(types.Type* type) {
    sys.assert(type != null, "called 'abbr' on null")
    sys.assert(type.container != null, "called 'type_abbr' with malformed type, container is null.")
    if string.strcmp(type.container, "int") == 0 {
        return "i"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "b"
    } elif string.strcmp(type.container, "void") == 0 {
        return "v"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "c"
    } elif string.strcmp(type.container, "ptr") == 0 {
        chr* buf
        io.asprintf(&buf, "%sp", type_abbr(type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        return type.repr
    } elif string.strcmp(type.container, "struct") == 0 {
        chr* buf = "s"
        for t := type.of; t != null; t = t.next {
            io.asprintf(&buf, "%s%s", buf, type_abbr(t))
        }
        return buf
    } elif string.strcmp(type.container, "function") == 0 {
        return "f"
    } elif string.strcmp(type.container, "error") == 0 {
        return "?"
    } else {
        io.printf(":coffee-error: unable to abbreviate type %s\n", type.container)
    }
    return (chr*) null
}

types.AssignableInfo* define_string(types.CompilerCtx* ctx, str text) {
    info := new_assignable_info((parser.Node*) null)
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".str%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

    -- global := (types.GlobalName*) sys.malloc(sizeof(types.GlobalName))
    -- global.identifier = llvm.string_to_llvm(text)

    info.type = new_type()
    info.type.container = "array"
    info.type.of = new_type()
    info.type.of.container = "chr"
    info.type.of.next = new_type()


    identifier := llvm.string_to_llvm(text)
    io.asprintf(&info.type.of.next.container, "%d", llvm.llvm_str_len(identifier))
    define_global(ctx, identifier, "string", info, false, false)

    return info
}

void define_global(types.CompilerCtx* ctx, str id, type, types.AssignableInfo* info, bool weak, bool compiled) {

    global := (types.GlobalName*) sys.malloc(sizeof(types.GlobalName))
    global.identifier = id
    global.global_type = type
    global.info = info
    global.compiled = compiled
    global.next = null
    global.weak = weak

    append_global(ctx, global)
}

void define_module(types.CompilerCtx* ctx, parser.Node* mod, str as_name, abspath) {
    info := new_assignable_info(mod)
    set_assignable_id(info, SCOPE_CONST, abspath)
    info.name_type = "module"
    info.type = null

    define_assignable(ctx, mod, as_name, info)
}

void append_anon_fn(types.CompilerCtx* ctx, str code) {
    fn := (types.AnonFn*) sys.malloc(sizeof(types.AnonFn))
    fn.code = code

    if ctx.anon_functions == null {
        ctx.anon_functions = fn
        fn.next = null
    } else {
        last := ctx.anon_functions
        for ; last.next != null; last = last.next {
        }
        last.next = fn
    }
}
void compile_anon_fn(types.CompilerCtx* ctx) {
    for fn := ctx.anon_functions; fn != null; fn = fn.next {
        io.fprintf(ctx.ir, "%s\n", fn.code)
    }
    ctx.anon_functions = null
}

void append_global(types.CompilerCtx* ctx, types.GlobalName* g) {

    if ctx.globals == null {
        ctx.globals = g
        return
    }

    last_global := ctx.globals
    for curr_global := ctx.globals; curr_global != null; curr_global = curr_global.next {
        if string.strcmp(curr_global.info.id, g.info.id) == 0 {
            return
        }
        last_global = curr_global
    }
    last_global.next = g
}


void append_error(types.CompilerCtx* ctx, errors.Error* e) {
    new_err := (types.ErrorList*) sys.malloc(sizeof(types.ErrorList))
    new_err.reported = false
    new_err.err = e
    new_err.next = null

    if ctx.errors == null {
        ctx.errors = new_err
        return
    }


    types.ErrorList* last
    for last = ctx.errors; last.next != null ; last = last.next {
    }

    last.next = new_err
}

chr* syn_function_name(parser.Node* stmt) {
    return stmt.children.next.value
}
parser.Node* skip_to_type(parser.Node* node, str type) {
    for n := node; n != null; n = n.next {
        if string.strcmp(n.type, type) == 0 {
            return n
        }
    }
    return (parser.Node*) null
}


types.Type* syn_function_type(types.CompilerCtx* ctx, parser.Node* stmt) {
    function_type := new_type()

    return_value_type := node_to_type(ctx, stmt.children)
    function_type.container = "function"
    function_type.of = return_value_type

    last_type := return_value_type
    params := syn_function_params(stmt)

    for param_ptr := params; param_ptr != null ; {
        if string.strcmp(param_ptr.type, "WORD") == 0 {
            last_type.next = type_clone(last_type)
            last_type.next.next = null
            last_type = last_type.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next
            }
            if param_ptr.next != null {
                param_ptr = param_ptr.next
            } else {
                param_ptr = null
            }
        } else {
            param_type := node_to_type(ctx, param_ptr.children)
            last_type.next = param_type
            last_type = param_type
            param_ptr = param_ptr.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next.next
            } else {
                param_ptr = null
            }
        }
    }

    -- start parsing argument types
    return function_type
}

parser.Node* syn_function_params(parser.Node* stmt) {
    params := skip_to_type(stmt, "fn_params")
    if params == null {
        return (parser.Node*) null
    }
    return params.children
}

types.Type* node_to_type(types.CompilerCtx* ctx, parser.Node* stmt) {
    if string.strcmp(stmt.type, "basic_type") == 0 {
        t := node_to_type(ctx, stmt.children)
        if stmt.next != null {
            if string.strcmp(stmt.next.type, "type_trailer") == 0 {
                fn_type := new_type()
                fn_type.container = "function"
                fn_type.of = t


                fst_operator := stmt.next.children.next
                if string.strcmp(fst_operator.type, "type_fn_params") == 0 {
                    last_fn_value := fn_type.of
                    for t := fst_operator.children; t != null; t = t.next {
                        -- skip commas
                        last_fn_value.next = node_to_type(ctx, t.children)
                        last_fn_value = last_fn_value.next
                        if t.next != null {
                            t = t.next
                        }
                    }
                }

                t_ptr := new_type()
                t_ptr.container = "ptr"
                t_ptr.of = fn_type
                t = t_ptr
            }
        }
        return t
    }

    t := new_type()

    if string.strcmp(stmt.type, "structdef") == 0 {
        t.container = "struct"
        t.info = null

        curr_type := skip_to_type(stmt.children, "type")
        if curr_type != null {
            t.of = node_to_type(ctx, curr_type.children)
            t.of.info = curr_type.next.value

            curr_t := t.of
            for curr_type = skip_to_type(curr_type.next, "type"); curr_type != null; curr_type = skip_to_type(curr_type.next, "type") {
                curr_t.next = node_to_type(ctx, curr_type.children)
                curr_t.next.info = curr_type.next.value
                curr_t = curr_t.next
            }
        }
        -- parse struct fields
    } elif string.strcmp(stmt.type, "dotted_name") == 0 {
        -- 1st resolve dotted name
        -- 2nd create type
        chr* err_msg
        base := find_defined(ctx, stmt)
        if base == null {
            io.asprintf(&err_msg, "Name %s is not defined in this scope", stmt.children.value)
            new_error(ctx, stmt, err_msg)
            t.container = "error"
            return t
        }

        t.container = "typealias"

        t.info = base.name
        t.repr = base.info.id

        t.of = base.info.type
    } elif string.strcmp(stmt.value, "str") == 0 {
        t.container = "ptr"
        t.of = new_type()
        t.of.container = "chr"
    } elif string.strcmp(stmt.type, "WORD") == 0 {
        t.container = stmt.value

    } elif string.strcmp(stmt.value, "...") == 0 {
        t.container = "vararg"
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to convert statement of type '%s' to type (%s)"), stmt.type, stmt.value)
        return (types.Type*) null
    }

    for ptr := stmt.next; ptr != null; ptr = ptr.next {
        if string.strcmp(ptr.value, "*") == 0 {
            -- pointer type
            pt := new_type()
            pt.container = "ptr"
            pt.of = t
            t = pt
        } elif string.strcmp(ptr.value, "[") == 0 {
            -- array type
            if string.strcmp(ptr.next.value, "]") == 0 {
                slice_type := new_type()
                slice_type.container = "struct"
                slice_type.info = "slice"

                slice_c_array := new_type()
                slice_c_array.container = "ptr"
                slice_c_array.info = "c_arr"
                slice_c_array.of = t
                slice_type.of = slice_c_array

                slice_len := new_type()
                slice_len.container = "int"
                slice_len.info = "len"
                slice_c_array.next = slice_len

                slice_cap := new_type()
                slice_cap.container = "int"
                slice_cap.info = "cap"
                slice_len.next = slice_cap

                t = slice_type
                ptr = ptr.next
            } else {
                -- TODO
            }
        } else {
            -- error: unable to parse this thing after type
            -- TODO: report it and quit since it's a compiler internal error
            io.printf(err_tmpl(ctx, ptr, "Unable to parse token '%s' after type definition"), ptr.value)
            return (types.Type*) null
        }
    }

    return t
}

