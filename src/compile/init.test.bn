import "./init" as compile
import "../std/testing" as testing
import "../std/string" as string
import "../std/io" as io
import "../std/ioutil" as ioutil
import "../std/sys" as sys
import "../parser" as parser
import "../peeker" as peeker
import "../lexer" as lexer
import "../errors" as errors

int main() {
    t := testing.init("compile/init.test.bn")

    testing.run(t, testfile(t, "./compile/__test__/01-empty_main"))
    testing.run(t, testfile(t, "./compile/__test__/02-return-digit"))
    testing.run(t, testfile(t, "./compile/__test__/03-return-void"))
    testing.run(t, testfile(t, "./compile/__test__/04-function-call"))
    testing.run(t, testfile(t, "./compile/__test__/05-compiles-functions-with-params"))
    testing.run(t, testfile(t, "./compile/__test__/06-parses-extern-functions"))
    testing.run(t, testfile(t, "./compile/__test__/07-parses-variable-declaration"))
    testing.run(t, testfile(t, "./compile/__test__/08-parses-variable-assignment"))
    testing.run(t, testfile(t, "./compile/__test__/09-parse-function-parameters"))
    testing.run(t, testfile(t, "./compile/__test__/0A-parses-global-variable"))
    testing.run(t, testfile(t, "./compile/__test__/0B-assigns-boolean-values"))
    testing.run(t, testfile(t, "./compile/__test__/0C-assigns-function-calls"))
    testing.run(t, testfile(t, "./compile/__test__/0D-parses-string"))
    testing.run(t, testfile(t, "./compile/__test__/0E-parses-if-else-block"))
    testing.run(t, testfile(t, "./compile/__test__/0F-parses-if-else-block-content"))
    testing.run(t, testfile(t, "./compile/__test__/10-compile-expressions"))
    testing.run(t, testfile(t, "./compile/__test__/11-compile-struct"))
    testing.run(t, testfile(t, "./compile/__test__/12-compiles-ptr"))
    testing.run(t, testfile(t, "./compile/__test__/13-compiles-type-alias"))
    testing.run(t, testfile(t, "./compile/__test__/14-casting"))
    testing.run(t, testfile(t, "./compile/__test__/15-array-address"))
    testing.run(t, testfile(t, "./compile/__test__/16-import"))
    testing.run(t, testfile(t, "./compile/__test__/17-imports-types"))
    testing.run(t, testfile(t, "./compile/__test__/18-multi-parameters"))
    testing.run(t, testfile(t, "./compile/__test__/19-ignores-head-comment"))
    testing.run(t, testfile(t, "./compile/__test__/1A-parses-vararg"))
    testing.run(t, testfile(t, "./compile/__test__/1B-parses-for-loop"))
    testing.run(t, testfile(t, "./compile/__test__/1C-parses-for-loop-without-init"))
    testing.run(t, testfile(t, "./compile/__test__/1D-parses-for-loop-without-increment"))
    testing.run(t, testfile(t, "./compile/__test__/1E-parses-for-loop-with-assignment-as-increment"))
    testing.run(t, testfile(t, "./compile/__test__/1F-compiles-char-values"))
    testing.run(t, testfile(t, "./compile/__test__/20-compiles-arguments-after-implicit-declaration"))
    testing.run(t, testfile(t, "./compile/__test__/21-compiles-more-expressions"))
    testing.run(t, testfile(t, "./compile/__test__/22-extracts-cell-types-from"))
    testing.run(t, testfile(t, "./compile/__test__/23-compiles-variable-types"))
    testing.run(t, testfile(t, "./compile/__test__/24-reads-type-from-extern-function"))
    testing.run(t, testfile(t, "./compile/__test__/25-correctly-calls-extern-function"))
    testing.run(t, testfile(t, "./compile/__test__/26-can-import-directires-with-relative-imports"))
    testing.run(t, testfile(t, "./compile/__test__/27-does-not-include-module-twice"))
    testing.run(t, testfile(t, "./compile/__test__/28-can-call-imported-externs"))
    testing.run(t, testfile(t, "./compile/__test__/29-auto-resolves-pointers"))
    testing.run(t, testfile(t, "./compile/__test__/2A-imports-global-variables"))
    testing.run(t, testfile(t, "./compile/__test__/2B-correctly-implements-casting"))
    testing.run(t, testfile(t, "./compile/__test__/2C-correctly-resolves-struct-fields"))
    testing.run(t, testfile(t, "./compile/__test__/2D-can-call-functions-defined-later"))
    testing.run(t, testfile(t, "./compile/__test__/2E-can-compile-nested-attribute-access"))
    testing.run(t, testfile(t, "./compile/__test__/2F-test-recursive-calls"))
    testing.run(t, testfile(t, "./compile/__test__/30-correctly-casts-null"))
    testing.run(t, testfile(t, "./compile/__test__/31-prevent-compile-globals-multiple-times"))
    testing.run(t, testfile(t, "./compile/__test__/32-correctly-counts-string-size"))
    testing.run(t, testfile(t, "./compile/__test__/33-correctly-indexes-strings"))
    testing.run(t, testfile(t, "./compile/__test__/34-compares-strings-to-null"))


    testing.cleanup(t)
    return 0
}


chr* read_testfile(str filename, str ext) {
    chr* full_filename
    io.asprintf(&full_filename, "%s.%s", filename, ext)

    f := io.fopen(full_filename, "r")
    if f == null {
        sys.free(full_filename)
        return (chr*) null
    }

    sys.free(full_filename)

    fd := io.fileno(f)
    content := ioutil.readall(fd)
    io.fclose(f)
    return content
}

-- reads content of input file
-- expects content of output file
int testfile(testing.T* t, str filename) {
    testing.setup(t, filename)

    -- prepare grammar file
    grammar_file := io.fopen("./syntax.txt", "r")
    ctx := parser.new_context(grammar_file)
    grammar := parser.parse_grammar(ctx)
    sys.free((chr*) ctx)

    chr* input_filename
    io.asprintf(&input_filename, "%s.%s", filename, "in")
    int input_fd = io.open(input_filename, io.O_RDONLY)

    if input_fd <= 0 {
        testing.fail(t)
        return 0
    }
    p := peeker.new(input_fd)
    p.filename = input_filename

    tokens := lexer.tokenize(p, false)
    sys.free((chr*) p)

    ast := parser.ast(grammar, "start", tokens)
    if ast.err != null {
        testing.fail(t)
        errors.freport(t.out, ast.err)
        return 0
    }

    compiler_ctx := compile.new_context(io.tmpfile(), input_filename)
    compile.compile(compiler_ctx, ast.node)

    expect := read_testfile(filename, "out")
    if expect == null {
        testing.fail(t)
        io.fprintf(t.out, "Unable to open %s.out\0A", filename)
        return 0
    }

    outfile := compiler_ctx.ir
    io.rewind(outfile)
    got := ioutil.readall(io.fileno(outfile))

    testing.assert_equal_str(t, expect, got)
    return 0
}

