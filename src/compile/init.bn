import "../std/sys" as sys
import "../std/io" as io
import "../parser" as parser
import "../std/string" as string

import "../parser.debug" as parser_debug
import "../errors" as errors
import "./shunting_yard" as sy

alias ErrorList = struct {
    errors.Error* err,
    ErrorList* next,
}
int ErrorList_size = 16

alias Type = struct {
    chr* container,


    chr* info, -- extra info attached to this type entry (for struct field names)

    -- NOTE: each "basic" type is not allowed to have a 'next'
    -- value

    Type* of,
    Type* next,

    -- Type* of,
    -- chr* container,
}
int Type_size = 32

alias AssignableInfo = struct {
    -- uniquely identifies assignable
    chr* id,
    chr* name_type,
    Type* type,

    -- where was the assignable defined
    int line,
    int char_of_line,
}
int AssignableInfo_size = 32

alias ScopeItem = struct {
    chr* name,
    AssignableInfo* info,
    ScopeItem* next,
}
int ScopeItem_size = 24

alias GlobalName = struct {
    chr* identifier,

    chr* global_type, -- string, function, typealias
    AssignableInfo* info,
    GlobalName* next,
}
int GlobalName_size = 32

alias Scope = struct {
    ScopeItem* item,
    Scope* prev,
}
int Scope_size = 16

alias CompilerCtx = struct {
    parser.Node* root,
    io.File* ir,
    ErrorList* errors,
    Scope *scopes,
    GlobalName* globals,
    int counter,
}
int CompilerCtx_size = 52

int new_uid(CompilerCtx* ctx) {
    uid := ctx.counter
    ctx.counter = ctx.counter + 1
    return uid
}



CompilerCtx* new_context(io.File* fd) {
    CompilerCtx* ctx = (CompilerCtx*) sys.malloc(CompilerCtx_size)
    ctx.ir = fd
    ctx.root = (parser.Node*) null
    ctx.errors = null
    ctx.counter = 0
    ctx.scopes = null
    ctx.globals = null

    return (CompilerCtx*) ctx
}

void push_scope(CompilerCtx* ctx) {
    s := (Scope*) sys.malloc(Scope_size)
    s.prev = ctx.scopes
    s.item = null
    ctx.scopes = s
}
void pop_scope(CompilerCtx* ctx) {
    -- TODO: free this scope -> s := ctx.scopes
    sys.assert(ctx.scopes != null, ":coffee-error: 'pop_scope' called when ctx.scopes is null")
    ctx.scopes = ctx.scopes.prev
}

bool compile(CompilerCtx* ctx, parser.Node* ast) {
    if string.strcmp(ast.type, "start") != 0 {
        return false
    }

    -- push global context scope
    push_scope(ctx)

    for s := ast.children; s != null; s = s.next {
        compile_statement(ctx, s.children)
    }

    has_errors := ctx.errors != null
    for err := ctx.errors; err != null; err = err.next {
        errors.report(err.err)
    }
    pop_scope(ctx)


    -- add globals
    for g := ctx.globals; g != null; g = g.next {
        compile_global(ctx, g)
    }

    -- TODO: free errors
    return has_errors
}

str string_to_llvm(chr* text) {
    chr* buf
    str_len := string.strlen(text)
    chr* substr = sys.malloc(str_len)
    for i := 0; i < str_len -2; i = i + 1 {
        substr[i] = text[i + 1]
    }
    substr[str_len -2] = '\00'
    io.asprintf(&buf, "c\22%s\5C00\22", substr)
    sys.free(substr)

    return buf
}

void compile_global(CompilerCtx* ctx, GlobalName* g) {
    if string.strcmp(g.global_type, "string") == 0 {
        repr := string_to_llvm(g.identifier)
        io.fprintf(ctx.ir, "%s = constant %s %s\0A", g.info.id, type_repr(g.info.type), repr)
    }
}

str name_mangle(str original_name, str filename, Type* type) {
    chr* mangled_name

    io.asprintf(&mangled_name, "@%s", original_name)
    if string.strcmp(type.container, "function") == 0 {
        -- function  name is the concatenation of module, original name
        -- return value and parameters type
        if string.strcmp(original_name, "main") != 0 {
            chr* tmp_buff
            chr* swap_var
            for tp := type.of; tp != null; tp = tp.next {
                io.asprintf(&tmp_buff, "%s.%s", mangled_name, type_abbr(tp))

                swap_var = tmp_buff
                tmp_buff = mangled_name
                mangled_name = swap_var
                sys.free(tmp_buff)
            }
        }
    }

    return mangled_name
}

void compile_statement(CompilerCtx* ctx, parser.Node* stmt) {
    AssignableInfo* info
    Type* return_type

    if string.strcmp(stmt.type, "NL") == 0 {
        return
    } elif string.strcmp(stmt.type, "global") == 0 {
        assignable := skip_to_type(stmt.children, "assignable")
        a_info := compile_assignable(ctx, assignable)

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&info.id, "@%s", stmt.children.next.value)
        info.type = a_info.type

        io.fprintf(ctx.ir, "%s = constant %s %s\0A", info.id, type_repr(info.type), a_info.id)

    } elif string.strcmp(stmt.type, "typealias") == 0 {

        type_decl := skip_to_type(stmt.children, "type")
        type_name := stmt.children.next.value

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&info.id, "%%.%s.type", type_name)
        info.name_type = "typealias"
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        g := define_typealias(ctx, info, type_name)
        type_struct := node_to_type(ctx, type_decl.children)
        g.info.type = type_struct

        io.fprintf(ctx.ir, "%s = type %s\0A", info.id, type_repr(type_struct))

    } elif string.strcmp(stmt.type, "extern") == 0 {
        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.type = syn_function_type(ctx, stmt.children.next)
        info.name_type = "extern"
        io.asprintf(&info.id, "@%s", stmt.children.next.next.value)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.next = null
        return_type.info = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "declare %s %s(", type_repr(return_type), info.id)
        for pt := info.type.of.next; pt != null; pt = pt.next {
            if pt != info.type.of.next {
                io.fprintf(ctx.ir, ", ")
            }
            io.fprintf(ctx.ir, "%s", type_repr(pt))
        }

        io.fprintf(ctx.ir, ")\0A")
        sys.free((chr*) return_type)

    } elif string.strcmp(stmt.type, "function") == 0 {
        -- function definition
        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.name_type = "function"
        info.type = syn_function_type(ctx, stmt.children)

        name := syn_function_name(stmt)
        info.id = name_mangle(name, "", info.type)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line
        define_assignable(ctx, name, info)

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.info = null
        return_type.next = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "define %s %s(", type_repr(return_type), info.id)
        params := syn_function_params(stmt.children)
        for param_ptr := params; param_ptr != null ; {
            if param_ptr != params {
                param_ptr = param_ptr.next
                io.fprintf(ctx.ir, ", ")
            }
            param_type := node_to_type(ctx, param_ptr.children)
            io.fprintf(ctx.ir, "%s %%.%s.arg", type_repr(param_type), param_ptr.next.value)
            param_ptr = param_ptr.next.next
        }
        -- build function parameters string
        io.fprintf(ctx.ir, ") {\0A")
        compile_fn_params(ctx, params)

        fn_block := skip_to_type(stmt.children, "block")
        compile_block(ctx, fn_block)


        parser.Node* last_valid_instruction = (parser.Node*) null

        -- check if last instruction is a return stmt
        -- otherwise add implicit void return
        -- or signal an error
        for ci := fn_block.children; ci.next != null; ci = ci.next {
            if string.strcmp(ci.type, "NL") != 0 & string.strcmp(ci.type, "OPERATOR") != 0 {
                last_valid_instruction = ci
            }
        }

        add_implicit_return := false
        if last_valid_instruction == null {
            add_implicit_return = true
        } elif string.strcmp(last_valid_instruction.children.type, "return") != 0 {
            add_implicit_return = true
        }

        if add_implicit_return {
            if string.strcmp(type_repr(return_type), "void") != 0 {
                new_error(ctx, fn_block, "missing return value")
            } else {
                io.fprintf(ctx.ir, "ret void\0A")
            }
        }

        io.fprintf(ctx.ir, "}\0A")

    } else {

        chr* err_buf
        io.asprintf(&err_buf, "Unable to convert statement of type %s to ast", stmt.type)
        new_error(ctx, stmt, err_buf)
    }
}

void compile_fn_params(CompilerCtx* ctx, parser.Node* fn_params) {
    for param_ptr := fn_params; param_ptr != null ; {
        if param_ptr != fn_params {
            param_ptr = param_ptr.next
        }

        var_name := param_ptr.next.value

        param_info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&param_info.id, "%%%s", var_name)
        param_info.name_type = "variable"
        param_info.type = node_to_type(ctx, param_ptr.children)
        param_info.line = param_ptr.line
        param_info.char_of_line = param_ptr.char_of_line

        param_info_tr := type_repr(param_info.type)
        io.fprintf(ctx.ir, "%s = alloca %s\0A", param_info.id, param_info_tr)
        define_assignable(ctx, var_name, param_info)
        io.fprintf(ctx.ir, "store %s %%.%s.arg, %s* %s\0A", param_info_tr, var_name, param_info_tr, param_info.id)
        param_ptr = param_ptr.next.next
    }
}


void compile_block(CompilerCtx* ctx, parser.Node* stmt) {
    push_scope(ctx)
    -- parse only expressions
    for b := stmt.children; b != null ; b = b.next {
        if string.strcmp(b.type, "expression") == 0 {
            compile_expression(ctx, b.children)
        }
    }
    pop_scope(ctx)
}

AssignableInfo* compile_fn_call(CompilerCtx* ctx, parser.Node* stmt) {
    info := compile_addr(ctx, stmt)
    args := skip_to_type(stmt, "fn_args")
    chr* params_buff = ""
    chr* tmp
    if args != null {
        start := skip_to_type(args.children, "assignable")
        for pp := start; pp != null; pp = skip_to_type(pp, "assignable") {
            if pp != start {
                io.asprintf(&tmp, "%s, ", params_buff)
                chr* tmp_buff = params_buff
                params_buff = tmp
                tmp = tmp_buff
                sys.free(tmp)
            }
            a_info := compile_assignable(ctx, pp)
            io.asprintf(&params_buff, "%s%s %s", params_buff, type_repr(a_info.type), a_info.id)
            pp = pp.next
        }
    }

    chr* uid = ""
    if string.strcmp(type_repr(info.type.of), "void") != 0 {
        io.asprintf(&uid, "%%.tmp%d", new_uid(ctx))
    }

    if string.strcmp(uid, "") == 0 {
        io.fprintf(ctx.ir, "call %s %s(%s)\0A", type_repr(info.type), info.id, params_buff)
        return (AssignableInfo*) null

    } else {
        io.fprintf(ctx.ir, "%s = call %s %s(%s)\0A", uid, type_repr(info.type), info.id, params_buff)
    }
    -- get function arguments

    AssignableInfo* call_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
    call_info.type = info.type.of
    call_info.type.next = null
    call_info.id = uid

    return (AssignableInfo*) call_info
}

void compile_expression(CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg
    expr_type := stmt.type

    AssignableInfo* info = (AssignableInfo*) null
    parser.Node* assignable
    AssignableInfo* a_info = (AssignableInfo*) null

    if string.strcmp(expr_type, "return") == 0 {
        if string.strcmp(stmt.children.next.type, "NL") != 0 {
            info = compile_assignable(ctx, stmt.children.next)
            io.fprintf(ctx.ir, "ret %s %s\0A", type_repr(info.type), info.id)
        } else {
            io.fprintf(ctx.ir, "ret void\0A")
        }

    } elif string.strcmp(expr_type, "NL") == 0 {
    } elif string.strcmp(expr_type, "fn_call") == 0 {
        -- get function name from destination
        compile_fn_call(ctx, stmt.children)
        -- get function arguments
    } elif string.strcmp(expr_type, "declaration") == 0 {

        Type* decl_type = (Type*) null
        if string.strcmp(stmt.children.type, "type") == 0 {
            decl_type = node_to_type(ctx, stmt.children.children)
        }

        assignable = skip_to_type(stmt.children, "assignable")
        if assignable != null {
            a_info = compile_assignable(ctx, assignable)
        }

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.name_type = "variable"
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line
        var_name := skip_to_type(stmt.children, "WORD")

        sys.assert(var_name != null, ":coffee-error: unalbe to get declaration name")

        io.asprintf(&info.id, "%%%s", var_name.value)
        if decl_type != null {
            info.type = decl_type
        } elif a_info != null {
            info.type = a_info.type
        }
        var_type_repr := type_repr(info.type)
        if a_info != null {
            a_type_repr := type_repr(a_info.type)
            type_error := false
            if string.strlen(a_type_repr) != string.strlen(var_type_repr) {
                type_error = true
            } elif string.strcmp(a_type_repr, var_type_repr) != 0 {
                type_error = true
            }

            if type_error {
                io.asprintf(&err_msg, "cannot assign type '%s' to variable of type '%s'", a_type_repr, var_type_repr)
                new_error(ctx, stmt, err_msg)
            }
        }
        define_assignable(ctx, var_name.value, info)

        io.fprintf(ctx.ir, "%s = alloca %s\0A", info.id, var_type_repr)
        if a_info != null {
            io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), a_info.id, var_type_repr, info.id)
        }

    } elif string.strcmp(expr_type, "assignment") == 0 {
        assignable = skip_to_type(stmt.children, "assignable")
        dest := compile_addr(ctx, stmt.children)
        if dest == null {
            io.asprintf(&err_msg, "%s was not declared in this scope", stmt.children.children.children.value)
            new_error(ctx, stmt, err_msg)
            return
        }
        a_info = compile_assignable(ctx, assignable)

        io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), a_info.id, type_repr(dest.type), dest.id)
    } elif string.strcmp(expr_type, "if_block") == 0 {
        compile_if_block(ctx, stmt)
    } else {
        io.printf(":coffee-error: unable to compile expression '%s'\0A", expr_type)
    }
}


void compile_if_block(CompilerCtx* ctx, parser.Node* stmt) {

    assignable := skip_to_type(stmt.children, "assignable")
    a_info := compile_assignable(ctx, assignable)

    if_id := new_uid(ctx)
    io.fprintf(ctx.ir, "br %s %s, label %%.if.true.%d, label %%.if.false.%d\0A", type_repr(a_info.type), a_info.id, if_id, if_id)
    io.fprintf(ctx.ir, ".if.true.%d:\0A", if_id)
    block := skip_to_type(stmt.children, "block")
    compile_block(ctx, block)
    io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
    io.fprintf(ctx.ir, ".if.false.%d:\0A", if_id)

    else_block := skip_to_type(stmt.children, "elif_block")
    if else_block != null {
        if string.strcmp(else_block.children.type, "else_block") == 0 {
            block = skip_to_type(else_block.children.children, "block")
            compile_block(ctx, block)
        } else {
            compile_if_block(ctx, else_block)
        }
    }

    -- compile any elif blocks
    io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
    io.fprintf(ctx.ir, ".if.end.%d:\0A", if_id)
}


void new_error(CompilerCtx* c, parser.Node* curr_node, str msg) {
    if curr_node != null {
        err := errors.new(curr_node.filename, curr_node.line, curr_node.char_of_line, msg)
        append_error(c, err)
    } else {
        sys.assert(false, "Programming error, unable to create new error from null node")
    }
}

-- binds the assignable to a given name in the current scope
void define_assignable(CompilerCtx* ctx, str name, AssignableInfo* info) {
    sys.assert(ctx.scopes != null, ":coffee-error: 'define_assignable' could not be called if context scopes are null")
    current_scope := ctx.scopes

    -- check that assignable is not defined on this context
    -- for item := current_scope.item; item != null; item = item.next {
    -- }

    newitem := (ScopeItem*) sys.malloc(ScopeItem_size)
    newitem.name = name
    newitem.info = info
    newitem.next = null

    if current_scope.item == null {
        current_scope.item = newitem
        return
    }

    for last_item := current_scope.item; last_item.next != null; last_item = last_item.next {
    }
    last_item.next = newitem
}

-- returns the 'base' information of the dotted name
AssignableInfo* find_defined(CompilerCtx* ctx, parser.Node* dotted_name) {
    sys.assert(ctx.scopes != null, ":coffee-error: 'find_defined' could not be called if context scopes are null")

    assignable_name := dotted_name.children.value
    for s := ctx.scopes; s != null; s = s.prev {
        for item := s.item; item != null; item = item.next {
            if string.strcmp(item.name, assignable_name) == 0 {
                return item.info
            }
        }
    }

    -- check global scopes
    for g := ctx.globals; g != null; g = g.next {
        if string.strcmp(g.global_type, "string") != 0 {
            if string.strcmp(g.identifier, assignable_name) == 0 {
                return g.info
            }
        }
    }

    return (AssignableInfo*) null
}

AssignableInfo* get_dotted_name(CompilerCtx* c, parser.Node* dot_name_ptr, AssignableInfo* info) {
    chr* err_msg

    if string.strcmp(info.name_type, "function") == 0 {
        -- got a function, cannot read dot names anymore
        if dot_name_ptr.next != null {
            io.asprintf(&err_msg, "cannot get attribute %s from function type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
        }
        return info
    } elif string.strcmp(info.name_type, "variable") == 0 & dot_name_ptr.next != null{
        if string.strcmp(info.type.container, "struct") != 0 {
            io.asprintf(&err_msg, "cannot get attribute %s from non struct type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
        }

        field_name := dot_name_ptr.next.next.value

        -- struct
        quit := false
        field_id := 0
        found_field := (Type*) null

        for field := info.type.of; quit == false; field = field.next {
            if field == null {
                quit = true
            } elif string.strcmp(field.info, field_name) == 0 {
                quit = true
                found_field = field
            } else {
                field_id = field_id + 1
            }
        }

        if found_field == null {
            io.asprintf(&err_msg, "field %s not defined in struct %s", field_name, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
            return (AssignableInfo*) null
        }

        new_info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
        new_info.type = found_field
        io.asprintf(&new_info.id, "%%.tmp%d", new_uid(c))
        new_info.name_type = "variable"
        new_info.line = dot_name_ptr.line
        new_info.char_of_line = dot_name_ptr.char_of_line

        info_tr := type_repr(info.type)
        io.fprintf(c.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\0A", new_info.id, info_tr, info_tr, info.id, field_id)

        return get_dotted_name(c, dot_name_ptr.next.next, new_info)

    } elif string.strcmp(info.name_type, "variable") == 0 {
        return info
    }

    io.printf(":coffee-error: `get_dotted_name` does not handle type: %s\0A", info.name_type)
    return (AssignableInfo*) null
}

-- returns address for node
AssignableInfo* compile_addr(CompilerCtx* ctx, parser.Node* curr_node) {
    if string.strcmp(curr_node.type, "destination") != 0 {
        io.printf("'compile_addr' could only be called on destinations for now. (called on %s)\0A", curr_node.type)
        return (AssignableInfo*) null
    }

    -- type + id of addr
    assignable_name := curr_node.children
    info := find_defined(ctx, assignable_name)
    if info == null {
        -- error! name is not defined
        chr* err_msg
        io.asprintf(&err_msg, "name %s is not defined\0A", assignable_name.value)
        new_error(ctx, curr_node, err_msg)
        return (AssignableInfo*) null
    }


    base := get_dotted_name(ctx, assignable_name.children, info)

    -- node has a following square bracket, do something
    for addr := curr_node.children.next; addr != null; addr = addr.next.next.next {
        index := addr.next
        index_info := compile_assignable(ctx, index)

        base_type := type_repr(base.type)
        index_type := type_repr(index_info.type)

        tmp_id := new_uid(ctx)
        io.fprintf(ctx.ir, "%%.tmp%d = load %s, %s* %s\0A", tmp_id, base_type, base_type, base.id)

        chr* new_id
        io.asprintf(&new_id, "%%.tmp%d", new_uid(ctx))

        base.type = base.type.of
        base_type_2 := type_repr(base.type)

        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %%.tmp%d, %s %s\0A", new_id, base_type_2, base_type_2, tmp_id, index_type, index_info.id)

        base.id = new_id
    }
    return base
}


alias StackHead = struct {
    sy.SYStack* h,
}
int StackHead_size = 8

AssignableInfo* compile_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    assignable_start := skip_to_type(curr_node.children, "mono_assignable")
    operator_stack := sy.sy_algorithm(assignable_start)

    stack := (StackHead*) sys.malloc(StackHead_size)
    stack.h = operator_stack

    info := compile_assignable_stack(ctx, stack)

    cast := skip_to_type(curr_node.children, "cast")
    if cast != null {
        cast_type := skip_to_type(cast.children, "type")

        new_type := node_to_type(ctx, cast_type.children)
        chr* new_id
        io.asprintf(&new_id, "%%.tmp%d", new_uid(ctx))

        io.fprintf(ctx.ir, "%s = bitcast %s %s to %s\0A", new_id, type_repr(info.type), info.id, type_repr(new_type))

        info.id = new_id
        info.type = new_type
    }
    return info
}

AssignableInfo* compile_assignable_stack(CompilerCtx* ctx, StackHead* stack) {
    if string.strcmp(stack.h.n.type, "mono_assignable") == 0 {
        return compile_mono_assignable(ctx, stack.h.n)
    }
    operator := stack.h.n.children

    stack.h = stack.h.prev
    A := compile_assignable_stack(ctx, stack)

    stack.h = stack.h.prev
    B := compile_assignable_stack(ctx, stack)

    op_info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
    op_info.type = operator_type(operator)

    op_id := new_uid(ctx)
    io.asprintf(&op_info.id, "%%.tmp%d", op_id)
    io.fprintf(ctx.ir, "%s = %s %s %s, %s\0A", op_info.id, operator_op(operator), type_repr(A.type), A.id, B.id)

    return op_info
}

str operator_op(parser.Node* op) {
    if op == null {
        io.printf(":cofee-error: called 'operator_op' with null\0A")
    }
    if string.strcmp(op.value, "+") == 0 {
        return "add"
    } elif string.strcmp(op.value, "-") == 0 {
        return "sub"
    } elif string.strcmp(op.value, "*") == 0 {
        return "mul"
    } elif string.strcmp(op.value, "/") == 0 {
        return "sdiv"
    } elif string.strcmp(op.value, "==") == 0 {
        return "icmp eq"
    } else {

        io.printf(":coffee-error: operator '%s' not implemented\0A", op.value)
    }
    return "add"
}

Type* operator_type(parser.Node* op) {
    type := (Type*) sys.malloc(Type_size)
    type.info = null
    type.of = null
    type.next = null
    if string.strcmp(op.value, "==") == 0 {
        type.container = "bool"
    } else {
        type.container = "int"
    }
    return type
}

AssignableInfo* compile_mono_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    AssignableInfo* assignable_info = (AssignableInfo*) null
    mono := curr_node
    chr* err_buf

    if string.strcmp(mono.children.type, "NUMBER") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.of = null
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "int"
        assignable_info.id = mono.children.value

    } elif string.strcmp(mono.children.type, "WORD") == 0 {
        if string.strcmp(mono.children.value, "null") != 0 {
            io.printf(":coffee-error: unable to interpret %s as mono_assignable\0A")
            return (AssignableInfo*) null
        }
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.id = "null"
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "nullptr"
        assignable_info.type.of = null

    } elif string.strcmp(mono.children.type, "addr_destination") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        dest := skip_to_type(mono.children.children, "destination")

        var_info := find_defined(ctx, dest.children)
        if var_info == null {
            io.asprintf(&err_buf, "Name %s is not defined in this scope", dest.children.children.value)
            new_error(ctx, curr_node, err_buf)
            return assignable_info
        }
        var_type_repr := type_repr(var_info.type)

        io.asprintf(&assignable_info.id, "%%.tmp%d", new_uid(ctx))
        assignable_info.type = var_info.type
        for ptr := mono.children.children; ptr != dest; ptr = ptr.next {
            new_type := (Type*) sys.malloc(Type_size)
            new_type.of = assignable_info.type
            new_type.container = "ptr"
            new_type.next = null
            new_type.info = null

            assignable_info.type = new_type
        }

        if mono.children.children != dest {
            -- it's a pointer, load it's address
            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0\0A", assignable_info.id, var_type_repr, var_type_repr, var_info.id)
        } else {
            -- it's a variable, load it's content
            io.fprintf(ctx.ir, "%s = load %s, %s* %s\0A", assignable_info.id, var_type_repr, var_type_repr, var_info.id)
        }

    } elif string.strcmp(mono.children.type, "boolean") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.info = null
        assignable_info.type.of = null
        assignable_info.type.container = "bool"
        if string.strcmp(mono.children.children.value, "false") == 0 {
            assignable_info.id = "0"
        } else {
            assignable_info.id = "1"
        }
    } elif string.strcmp(mono.children.type, "fn_call") == 0 {
        assignable_info = compile_fn_call(ctx, mono.children.children)
    } elif string.strcmp(mono.children.type, "STRING") == 0 {
        string_info := define_string(ctx, mono.children.value) -- defines strings for future reuse, plus defines global functions or data structures when used
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&assignable_info.id, "%%.tmp%d", new_uid(ctx))

        str_tr := type_repr(string_info.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s*%s, i32 0, i32 0\0A", assignable_info.id, str_tr, str_tr, string_info.id)

        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "ptr"
        assignable_info.type.of = (Type*) sys.malloc(Type_size)
        assignable_info.type.of.info = null
        assignable_info.type.of.container = "chr"
        assignable_info.type.of.of = null
        assignable_info.type.of.next = null

    } elif string.strcmp(mono.children.type, "CHR") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        chr_len := string.strlen(mono.children.value)
        assignable_info.id = "0"

        if chr_len == 5 {
            -- CHR in the form of "\XX" (hex numbers)
            intval := 0
            io.sscanf(mono.children.value, "'\5C%x'", &intval)
            io.asprintf(&assignable_info.id, "%d", intval)

        } elif chr_len == 3 {
            -- CHR in the form of "X" (single character)
            io.printf(":coffee-error: not implemented yet\0A")
        } else {
            -- malformed character
            io.asprintf(&err_buf, "Invalid character")
            new_error(ctx, mono, err_buf)
        }

        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.container = "chr"
        assignable_info.type.of = null
        assignable_info.type.info = null
        assignable_info.type.next = null
    } else {
        io.printf(":coffee-error: unable to compile assignable of type %s\0A", mono.children.type)
        return (AssignableInfo*) null
    }

    assignable_info.line = curr_node.line
    assignable_info.char_of_line = curr_node.char_of_line
    return (AssignableInfo*) assignable_info
}

str type_abbr(Type* type) {
    sys.assert(type != null, "called 'abbr' on null")
    sys.assert(type.container != null, "called 'type_abbr' with malformed type, container is null.")
    if string.strcmp(type.container, "int") == 0 {
        return "i"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "b"
    } elif string.strcmp(type.container, "void") == 0 {
        return "v"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "c"
    } elif string.strcmp(type.container, "ptr") == 0 {
        chr* buf
        io.asprintf(&buf, "%sp", type_abbr(type.of))
        return buf
    }
    return (chr*) null
}

AssignableInfo* define_string(CompilerCtx* ctx, str text) {
    info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
    io.asprintf(&info.id, "@.str%d", new_uid(ctx))
    info.type = (Type*) sys.malloc(Type_size)
    info.type.info = null
    info.type.container = "array"
    info.type.of = (Type*) sys.malloc(Type_size)
    info.type.of.info = null
    info.type.of.container = "chr"
    info.type.of.of = null
    info.type.of.next = (Type*) sys.malloc(Type_size)
    info.type.of.next.info = null
    info.type.of.next.of = null
    io.asprintf(&info.type.of.next.container, "%d", string.strlen(text) -2 +1)

    global := (GlobalName*) sys.malloc(GlobalName_size)
    global.identifier = text
    global.global_type = "string"
    global.next = null
    global.info = info
    append_global(ctx, global)
    return info
}

GlobalName* define_typealias(CompilerCtx* ctx, AssignableInfo* typeinfo, str name) {
    global := (GlobalName*) sys.malloc(GlobalName_size)
    global.identifier = name
    global.global_type = "type"
    global.next = null
    global.info = typeinfo
    append_global(ctx, global)

    return global
}

void append_global(CompilerCtx* ctx, GlobalName* g) {
    if ctx.globals == null {
        ctx.globals = g
    } else {
        GlobalName* last_global
        for last_global = ctx.globals; last_global.next != null; last_global = last_global.next {
        }
        last_global.next = g
    }
}

str type_repr(Type* type) {
    sys.assert(type != null, "called 'type_repr' on null")
    sys.assert(type.container != null, "called 'type_repr' with malformed type, container is null.")
    chr* buf

    if string.strcmp(type.container, "int") == 0 {
        return "i32"
    } elif string.strcmp(type.container, "void") == 0 {
        return "void"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "i1"
    } elif string.strcmp(type.container, "nullptr") == 0 {
        return "ptr"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "i8"
    } elif string.strcmp(type.container, "function") == 0 {
        io.asprintf(&buf, "%s(", type_repr(type.of))
        for p := type.of.next; p != null; p = p.next {
            if p != type.of.next {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(p))
        }
        io.asprintf(&buf, "%s)", buf)
        return buf
    } elif string.strcmp(type.container, "ptr") == 0 {
        io.asprintf(&buf, "%s*", type_repr(type.of))
        return buf
    } elif string.strcmp(type.container, "struct") == 0 {
        -- io.asprintf(&buf, "{%s}", type_repr(type.of)
        io.asprintf(&buf, "{")
        for t := type.of; t != null; t = t.next {
            if t != type.of {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(t))
        }
        io.asprintf(&buf, "%s}", buf)
        return buf
    } elif string.strcmp(type.container, "array") == 0 {
        io.asprintf(&buf, "[%s x %s]", type.of.next.container, type_repr(type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        return type.of.info
    } else {
        io.printf(":coffee-error: 'type_repr' not implemented for type '%s'\0A", type.container)
    }

    return (chr*) null
}

void append_error(CompilerCtx* ctx, errors.Error* e) {
    new_err := (ErrorList*) sys.malloc(ErrorList_size)
    new_err.err = e
    new_err.next = null

    if ctx.errors == null {
        ctx.errors = new_err
        return
    }

    for last := ctx.errors; last.next != null ; last = last.next {
    }

    last.next = new_err
}

chr* syn_function_name(parser.Node* stmt) {
    return stmt.children.next.value
}
parser.Node* skip_to_type(parser.Node* node, str type) {
    for n := node; n != null; n = n.next {
        if string.strcmp(n.type, type) == 0 {
            return n
        }
    }
    return (parser.Node*) null
}


Type* syn_function_type(CompilerCtx* ctx, parser.Node* stmt) {
    function_type := (Type*) sys.malloc(Type_size)
    function_type.info = null

    return_value_type := node_to_type(ctx, stmt.children)
    function_type.container = "function"
    function_type.of = return_value_type

    last_type := return_value_type
    params := syn_function_params(stmt)

    for param_ptr := params; param_ptr != null ; param_ptr = skip_to_type(param_ptr, "type") {
        param_type := node_to_type(ctx, param_ptr.children)
        last_type.next = param_type
        last_type = param_type
        param_ptr = param_ptr.next
    }

    -- start parsing argument types
    return function_type
}

parser.Node* syn_function_params(parser.Node* stmt) {
    params := skip_to_type(stmt, "fn_params")
    if params == null {
        return (parser.Node*) null
    }
    return params.children
}

Type* node_to_type(CompilerCtx* ctx, parser.Node* stmt) {
    t := (Type*) sys.malloc(Type_size)
    t.of = null
    t.next = null
    t.info = null

    if string.strcmp(stmt.type, "structdef") == 0 {
        t.container = "struct"
        t.info = null

        curr_type := skip_to_type(stmt.children, "type")
        if curr_type != null {
            t.of = node_to_type(ctx, curr_type.children)
            t.of.info = curr_type.next.value

            curr_t := t.of
            for curr_type = skip_to_type(curr_type.next, "type"); curr_type != null; curr_type = skip_to_type(curr_type.next, "type") {
                curr_t.next = node_to_type(ctx, curr_type.children)
                curr_t.next.info = curr_type.next.value
                curr_t = curr_t.next
            }
        }
        -- parse struct fields
    } elif string.strcmp(stmt.type, "WORD") == 0 {
        t.container = stmt.value
    } elif string.strcmp(stmt.type, "dotted_name") == 0 {
        -- 1st resolve dotted name
        -- 2nd create type
        base := find_defined(ctx, stmt)
        if base == null {
            chr* err_msg
            io.asprintf(&err_msg, "Name %s is not defined in this scope", stmt.children.value)
            new_error(ctx, stmt, err_msg)
            t.container = "error"
            return t
        }

        t.container = "typealias"
        t.of = (Type*) sys.malloc(Type_size)
        t.of.container = "alias"
        t.of.next = null
        t.of.info = base.id
    } else {
        io.printf(":coffee-error: unable to convert statement of type '%s' to type\0A", stmt.type)
    }

    for ptr := stmt.next; ptr != null; ptr = ptr.next {
        pt := (Type*) sys.malloc(Type_size)
        pt.container = "ptr"
        pt.of = t
        pt.next = null
        pt.info = null
        t = pt
    }

    return t
}
