import "../std/sys" as sys
import "../std/io" as io
import "../parser" as parser
import "../std/string" as string
import "../peeker" as peeker
import "../lexer" as lexer

import "../parser.debug" as parser_debug
import "../errors" as errors
import "./shunting_yard" as sy


alias ErrorList = struct {
    errors.Error* err,
    ErrorList* next,
}
int ErrorList_size = 16

alias Type = struct {
    chr* container,

    chr* info, -- extra info attached to this type entry (for struct field names)

    -- NOTE: each "basic" type is not allowed to have a 'next'
    -- value

    Type* of,
    Type* next,

    -- Type* of,
    -- chr* container,
}
int Type_size = 32

Type* type_clone(Type* t) {
    if t == null {
        return (Type*) null
    }

    Type* clone = (Type*) sys.malloc(Type_size)
    clone.of = type_clone(t.of)
    clone.next = type_clone(t.next)
    clone.container = t.container
    clone.info = t.info
    return clone
}

alias AssignableInfo = struct {
    -- uniquely identifies assignable
    chr* id,

    chr scope, -- adds @ before id if it's a global assignment, otherwise %
    chr* name_type,
    Type* type,

    -- where was the assignable defined
    int line,
    int char_of_line,
}
int AssignableInfo_size = 40

chr SCOPE_GLOBAL = '@'
chr SCOPE_LOCAL = '%'
chr SCOPE_CONST = ' '


AssignableInfo* new_assignable_info(parser.Node* node) {
    ptr := (AssignableInfo*) sys.malloc(AssignableInfo_size)
    ptr.scope = SCOPE_CONST
    ptr.id = null
    ptr.name_type = null
    ptr.type = null

    -- copy line and char of line from specified node
    if node != null {
        ptr.line = node.line
        ptr.char_of_line = node.char_of_line
    } else {
        ptr.line = 0
        ptr.char_of_line = 0
    }
    return ptr
}

void set_assignable_id(AssignableInfo* info, chr scope, chr* id) {
    info.id = id
    info.scope = scope
}

chr* repr_assignable_id(AssignableInfo* info) {
    if info.scope == SCOPE_CONST {
        return info.id
    }
    chr* buf
    io.asprintf(&buf, "%c%s", info.scope, info.id)
    return buf
}


alias ScopeItem = struct {
    chr* name,
    AssignableInfo* info,
    ScopeItem* next,
}
int ScopeItem_size = 24

alias GlobalName = struct {
    chr* identifier,

    chr* global_type, -- string, typealias, module
    AssignableInfo* info,
    GlobalName* next,
}
int GlobalName_size = 32

alias Scope = struct {
    chr* filename,
    ScopeItem* item,
    Scope* prev,
}
int Scope_size = 24

alias ModuleLookup = struct {
    chr* abspath,
    chr* prefix,
    ModuleLookup* next,
    Scope* scopes,
}
int ModuleLookup_size = 32


alias CompilerCtx = struct {
    parser.Node* root,
    io.File* ir,
    ErrorList* errors,
    GlobalName* globals,
    int counter,
    ModuleLookup* modules,
    chr* current_module,
}
int CompilerCtx_size = 60

void set_assignable_tmp_id(CompilerCtx* ctx, AssignableInfo* info) {
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".tmp%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_LOCAL, tmp_buff)
}

ModuleLookup* get_module(CompilerCtx* ctx, str filename) {
    for m := ctx.modules; m != null; m = m.next {
        if string.strcmp(m.abspath, filename) == 0 {
            return m
        }
    }
    return (ModuleLookup*) null
}
ModuleLookup* get_current_module(CompilerCtx* ctx) {
    return get_module(ctx, ctx.current_module)
}

int new_uid(CompilerCtx* ctx) {
    uid := ctx.counter
    ctx.counter = ctx.counter + 1
    return uid
}

CompilerCtx* new_context(io.File* fd, str filename) {
    CompilerCtx* ctx = (CompilerCtx*) sys.malloc(CompilerCtx_size)
    ctx.ir = fd
    ctx.root = (parser.Node*) null
    ctx.errors = null
    ctx.counter = 0
    ctx.globals = null
    ctx.current_module = filename

    ctx.modules = (ModuleLookup*) sys.malloc(ModuleLookup_size)
    ctx.modules.abspath = filename -- TODO: add initial filename here
    ctx.modules.scopes = null
    ctx.modules.prefix = ""
    ctx.modules.next = null

    return (CompilerCtx*) ctx
}

void push_scope(CompilerCtx* ctx) {
    s := (Scope*) sys.malloc(Scope_size)

    m := get_current_module(ctx)
    s.prev = m.scopes
    s.item = null
    m.scopes = s
}
void pop_scope(CompilerCtx* ctx) {
    -- TODO: free this scope -> s := ctx.scopes
    m := get_current_module(ctx)
    sys.assert(m.scopes != null, ":coffee-error: 'pop_scope' called when module.scopes is null")
    m.scopes = m.scopes.prev
}

bool compile_file(CompilerCtx* ctx, str filepath) {
    grammar_file := io.fopen("./syntax.txt", "r")
    grammar_ctx := parser.new_context(grammar_file)
    grammar := parser.parse_grammar(grammar_ctx)
    sys.free((chr*) grammar_ctx)

    int input_fd = io.open(filepath, io.O_RDONLY)

    p := peeker.new(input_fd)
    p.filename = filepath

    tokens := lexer.tokenize(p, false)
    ast := parser.ast(grammar, "start", tokens)
    return compile(ctx, ast.node)
}


bool compile(CompilerCtx* ctx, parser.Node* ast) {
    if string.strcmp(ast.type, "start") != 0 {
        return false
    }

    -- push global context scope
    push_scope(ctx)

    start := ast.children
    if string.strcmp(start.type, "head_comment") == 0 {
        start = start.next
    }

    for s := start; s != null; s = s.next {
        compile_statement(ctx, s.children)
    }
    has_errors := ctx.errors != null
    for err := ctx.errors; err != null; err = err.next {
        errors.report(err.err)
    }
    -- pop_scope(ctx)


    -- add globals
    for g := ctx.globals; g != null; g = g.next {
        compile_global(ctx, g)
    }

    -- TODO: free errors
    return has_errors
}

str string_to_llvm(chr* text) {
    chr* buf
    str_len := string.strlen(text)
    chr* substr = sys.malloc(str_len)
    for i := 0; i < str_len -2; i = i + 1 {
        substr[i] = text[i + 1]
    }
    substr[str_len -2] = '\00'
    io.asprintf(&buf, "c\22%s\5C00\22", substr)
    sys.free(substr)

    return buf
}

void compile_global(CompilerCtx* ctx, GlobalName* g) {
    if string.strcmp(g.global_type, "string") == 0 {
        repr := string_to_llvm(g.identifier)
        io.fprintf(ctx.ir, "%s = constant %s %s\0A", repr_assignable_id(g.info), type_repr(g.info.type), repr)
    }
}


chr* get_mod_prefix(CompilerCtx* ctx, str module_abspath) {
    m := get_current_module(ctx)
    return m.prefix
}


str name_mangle(CompilerCtx* ctx, parser.Node* fn, str original_name, Type* type) {
    chr* mangled_name

    chr* prefix = get_mod_prefix(ctx, fn.filename)
    io.asprintf(&mangled_name, "%s%s", prefix, original_name)
    if string.strcmp(type.container, "function") == 0 {
        -- function  name is the concatenation of module, original name
        -- return value and parameters type
        if string.strcmp(mangled_name, "main") != 0 {
            chr* tmp_buff
            chr* swap_var
            for tp := type.of; tp != null; tp = tp.next {
                io.asprintf(&tmp_buff, "%s.%s", mangled_name, type_abbr(tp))

                swap_var = tmp_buff
                tmp_buff = mangled_name
                mangled_name = swap_var
                sys.free(tmp_buff)
            }
        }
    }

    return mangled_name
}

void compile_statement(CompilerCtx* ctx, parser.Node* stmt) {
    AssignableInfo* info
    Type* return_type
    chr* err_buf
    chr* tmp_buff

    if string.strcmp(stmt.type, "NL") == 0 {
        return
    } elif string.strcmp(stmt.type, "global") == 0 {
        assignable := skip_to_type(stmt.children, "assignable")
        a_info := compile_assignable(ctx, assignable)

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        set_assignable_id(info, SCOPE_GLOBAL, stmt.children.next.value)
        info.type = a_info.type

        io.fprintf(ctx.ir, "%s = constant %s %s\0A", repr_assignable_id(info), type_repr(info.type), repr_assignable_id(a_info))

    } elif string.strcmp(stmt.type, "typealias") == 0 {

        type_decl := skip_to_type(stmt.children, "type")
        type_name := stmt.children.next.value

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        mod_from := get_current_module(ctx)

        io.asprintf(&tmp_buff, "%s.%s.type", mod_from.prefix, type_name)
        set_assignable_id(info, SCOPE_LOCAL, tmp_buff)

        info.name_type = "typealias"
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        g := define_typealias(ctx, info, type_name)
        type_struct := node_to_type(ctx, type_decl.children)
        g.info.type = type_struct

        io.fprintf(ctx.ir, "%s = type %s\0A", repr_assignable_id(info), type_repr(type_struct))

    } elif string.strcmp(stmt.type, "extern") == 0 {
        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.type = syn_function_type(ctx, stmt.children.next)
        info.name_type = "extern"
        set_assignable_id(info, SCOPE_GLOBAL, stmt.children.next.next.value)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.next = null
        return_type.info = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "declare %s %s(", type_repr(return_type), repr_assignable_id(info))
        for pt := info.type.of.next; pt != null; pt = pt.next {
            if pt != info.type.of.next {
                io.fprintf(ctx.ir, ", ")
            }
            io.fprintf(ctx.ir, "%s", type_repr(pt))
        }

        io.fprintf(ctx.ir, ")\0A")
        sys.free((chr*) return_type)

    } elif string.strcmp(stmt.type, "function") == 0 {
        -- function definition
        info = new_assignable_info(stmt)
        info.name_type = "function"
        info.type = syn_function_type(ctx, stmt.children)

        name := syn_function_name(stmt)
        tmp_buff = name_mangle(ctx, stmt, name, info.type)
        set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

        define_assignable(ctx, name, info)

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.info = null
        return_type.next = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "define %s %s(", type_repr(return_type), repr_assignable_id(info))
        params := syn_function_params(stmt.children)

        Type* param_type
        for param_ptr := params; param_ptr != null ; {
            if param_ptr != params {
                param_ptr = param_ptr.next
                io.fprintf(ctx.ir, ", ")
            }
            if string.strcmp(param_ptr.type, "type") == 0 {
                param_type = node_to_type(ctx, param_ptr.children)
                param_ptr = param_ptr.next
            }
            io.fprintf(ctx.ir, "%s %%.%s.arg", type_repr(param_type), param_ptr.value)
            param_ptr = param_ptr.next
        }
        -- build function parameters string
        io.fprintf(ctx.ir, ") {\0A")
        compile_fn_params(ctx, params)

        fn_block := skip_to_type(stmt.children, "block")
        compile_block(ctx, fn_block)


        parser.Node* last_valid_instruction = (parser.Node*) null

        -- check if last instruction is a return stmt
        -- otherwise add implicit void return
        -- or signal an error
        for ci := fn_block.children; ci.next != null; ci = ci.next {
            if string.strcmp(ci.type, "NL") != 0 & string.strcmp(ci.type, "OPERATOR") != 0 {
                last_valid_instruction = ci
            }
        }

        add_implicit_return := false
        if last_valid_instruction == null {
            add_implicit_return = true
        } elif string.strcmp(last_valid_instruction.children.type, "return") != 0 {
            add_implicit_return = true
        }

        if add_implicit_return {
            if string.strcmp(type_repr(return_type), "void") != 0 {
                new_error(ctx, fn_block, "missing return value")
            } else {
                io.fprintf(ctx.ir, "ret void\0A")
            }
        }

        io.fprintf(ctx.ir, "}\0A")

    } elif string.strcmp(stmt.type, "import") == 0 {
        -- 1. get file cwd
        -- check if module is already imported in module lookup
        mod_name := stmt.children.next.value
        -- mod_abspath := sys.malloc(4096)
        mod_abspath := stmt.filename

        cwd := sys.malloc(4096)
        cwd = sys.getcwd(cwd, 4096)

        dirname := sys.dirname(mod_abspath)
        io.asprintf(&mod_abspath, "%s/%s/", cwd, dirname)
        mod_abspath = sys.realloc(mod_abspath, 4096)

        offset := string.strlen(mod_abspath)

        for i := 1; mod_name[i] != '\22'; i = i + 1 {
            mod_abspath[offset + i-1] = mod_name[i]
        }
        last_idx := offset + string.strlen(mod_name) - 2
        mod_abspath[last_idx + 0] = '.'
        mod_abspath[last_idx + 1] = 'b'
        mod_abspath[last_idx + 2] = 'n'
        mod_abspath[last_idx + 3] = '\00'

        mod_abspath = sys.realpath(mod_abspath, sys.malloc(4096))
        if mod_abspath == null {
            io.asprintf(&err_buf, "'%s' file not found.", mod_name)
            return
        }

        -- define module lookup if not found
        -- found := false
        -- for m := ctx.modules; m.next != null & found == false; m = m.next {
        --     found = string.strcmp()
        -- }

        mod := (ModuleLookup*) sys.malloc(ModuleLookup_size)
        mod.abspath = mod_abspath
        mod.next = null
        mod.scopes = null
        io.asprintf(&mod.prefix, "m%d$", new_uid(ctx))

        for m := ctx.modules; m.next != null; m = m.next {
        }
        m.next = mod
        asname := stmt.children.next.next.next.value

        define_module(ctx, stmt, asname, mod.abspath)

        curr_mod := ctx.current_module
        ctx.current_module = mod.abspath
        compile_file(ctx, mod.abspath)
        ctx.current_module = curr_mod

    } else {
        io.printf(err_tmpl(ctx, stmt, "statement of type %s is not implemented"), stmt.type)
    }
}

chr* err_tmpl(CompilerCtx* ctx, parser.Node* stmt, chr* msg) {
    chr* buf
    io.asprintf(&buf, ":coffee-error: (%s: %d:%d) %s\0A", ctx.current_module, stmt.line, stmt.char_of_line, msg)
    return buf
}

void compile_fn_params(CompilerCtx* ctx, parser.Node* fn_params) {
    Type* param_type
    for param_ptr := fn_params; param_ptr != null ; {
        if param_ptr != fn_params {
            param_ptr = param_ptr.next
        }

        param_info := new_assignable_info(fn_params)
        param_info.name_type = "variable"
        if string.strcmp(param_ptr.type, "type") == 0 {
            param_type = node_to_type(ctx, param_ptr.children)
            param_ptr = param_ptr.next
        }
        param_info.type = param_type

        var_name := param_ptr.value
        set_assignable_id(param_info, SCOPE_LOCAL, var_name)

        param_info_tr := type_repr(param_info.type)
        io.fprintf(ctx.ir, "%s = alloca %s\0A", repr_assignable_id(param_info), param_info_tr)
        define_assignable(ctx, var_name, param_info)
        io.fprintf(ctx.ir, "store %s %%.%s.arg, %s* %s\0A", param_info_tr, var_name, param_info_tr, repr_assignable_id(param_info))
        param_ptr = param_ptr.next
    }
}


void compile_block(CompilerCtx* ctx, parser.Node* stmt) {
    push_scope(ctx)
    -- parse only expressions
    for b := stmt.children; b != null ; b = b.next {
        if string.strcmp(b.type, "expression") == 0 {
            compile_expression(ctx, b.children)
        }
    }
    pop_scope(ctx)
}

AssignableInfo* compile_fn_call(CompilerCtx* ctx, parser.Node* stmt) {
    info := compile_addr(ctx, stmt)
    args := skip_to_type(stmt, "fn_args")
    chr* params_buff = ""
    chr* tmp
    if args != null {
        start := skip_to_type(args.children, "assignable")
        for pp := start; pp != null; pp = skip_to_type(pp, "assignable") {
            if pp != start {
                io.asprintf(&tmp, "%s, ", params_buff)
                chr* tmp_buff = params_buff
                params_buff = tmp
                tmp = tmp_buff
                sys.free(tmp)
            }
            a_info := compile_assignable(ctx, pp)
            io.asprintf(&params_buff, "%s%s %s", params_buff, type_repr(a_info.type), repr_assignable_id(a_info))
            pp = pp.next
        }
    }

    if info == null {
        -- error
        return (AssignableInfo*) null
    }

    if string.strcmp(type_repr(info.type.of), "void") == 0 {
        io.fprintf(ctx.ir, "call %s %s(%s)\0A", type_repr(info.type), repr_assignable_id(info), params_buff)
        return (AssignableInfo*) null
    }

    call_info := new_assignable_info(stmt)
    set_assignable_tmp_id(ctx, call_info)
    call_info.type = info.type.of
    call_info.type.next = null

    io.fprintf(ctx.ir, "%s = call %s %s(%s)\0A", repr_assignable_id(call_info), type_repr(info.type), repr_assignable_id(info), params_buff)

    return (AssignableInfo*) call_info
}

void compile_expression(CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg
    expr_type := stmt.type

    AssignableInfo* info = (AssignableInfo*) null
    parser.Node* assignable
    AssignableInfo* a_info = (AssignableInfo*) null

    if string.strcmp(expr_type, "return") == 0 {
        if string.strcmp(stmt.children.next.type, "NL") != 0 {
            info = compile_assignable(ctx, stmt.children.next)
            io.fprintf(ctx.ir, "ret %s %s\0A", type_repr(info.type), repr_assignable_id(info))
        } else {
            io.fprintf(ctx.ir, "ret void\0A")
        }

    } elif string.strcmp(expr_type, "NL") == 0 {
        -- skip empty newlines
    } elif string.strcmp(expr_type, "fn_call") == 0 {
        compile_fn_call(ctx, stmt.children)
    } elif string.strcmp(expr_type, "declaration") == 0 {
        compile_declaration(ctx, stmt)
    } elif string.strcmp(expr_type, "assignment") == 0 {
        assignable = skip_to_type(stmt.children, "assignable")
        dest := compile_addr(ctx, stmt.children)
        if dest == null {
            io.asprintf(&err_msg, "%s was not declared in this scope", stmt.children.children.children.value)
            new_error(ctx, stmt, err_msg)
            return
        }
        a_info = compile_assignable(ctx, assignable)

        io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), repr_assignable_id(a_info), type_repr(dest.type), repr_assignable_id(dest))
    } elif string.strcmp(expr_type, "if_block") == 0 {
        compile_if_block(ctx, stmt)
    } elif string.strcmp(expr_type, "for_loop") == 0 {
        compile_for_loop(ctx, stmt)
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to compile expression '%s'"), expr_type)
    }
}

void compile_for_loop(CompilerCtx* ctx, parser.Node* stmt) {
    for_id := new_uid(ctx)
    init_stmt := stmt.children.next

    if string.strcmp(init_stmt.type, "declaration") == 0 {
        compile_declaration(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "assignment") == 0 {
        compile_expression(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "OPERATOR") == 0 {
        -- no init condition provided
    } else {
        -- coffee error
        io.printf(err_tmpl(ctx, init_stmt, "unable to compile statement of type %s in for loop init condition"), init_stmt.type)
        return
    }

    io.fprintf(ctx.ir, "br label %%.for.start.%d\0A", for_id)
    io.fprintf(ctx.ir, ".for.start.%d:\0A", for_id)

    -- check for 'for' condition
    fst_colon := skip_to_type(stmt.children, "OPERATOR")
    condition := fst_colon.next
    condition_info := compile_assignable(ctx, condition)
    io.fprintf(ctx.ir, "br %s %s, label %%.for.continue.%d, label %%.for.end.%d\0A", type_repr(condition_info.type), repr_assignable_id(condition_info), for_id, for_id)

    io.fprintf(ctx.ir, ".for.continue.%d:\0A", for_id)

    -- compile body

    snd_colon := skip_to_type(fst_colon.next, "OPERATOR")
    increment := snd_colon.next

    for_body := skip_to_type(snd_colon, "block")
    compile_block(ctx, for_body)

    -- compile increment statement only if it exists
    if increment != for_body {
        compile_expression(ctx, increment)
    }

    -- execute for increment before next loop
    io.fprintf(ctx.ir, "br label %%.for.start.%d\0A", for_id)
    io.fprintf(ctx.ir, ".for.end.%d:\0A", for_id)
}

AssignableInfo* compile_declaration(CompilerCtx* ctx, parser.Node* stmt) {
    Type* decl_type = (Type*) null
    AssignableInfo* a_info = (AssignableInfo*) null
    if string.strcmp(stmt.children.type, "type") == 0 {
        decl_type = node_to_type(ctx, stmt.children.children)
    }

    assignable := skip_to_type(stmt.children, "assignable")
    if assignable != null {
        a_info = compile_assignable(ctx, assignable)
    }

    info := new_assignable_info(stmt)
    info.name_type = "variable"
    var_name := skip_to_type(stmt.children, "WORD")

    sys.assert(var_name != null, ":coffee-error: unalbe to get declaration name")
    set_assignable_id(info, SCOPE_LOCAL, var_name.value)

    if decl_type != null {
        info.type = decl_type
    } elif a_info != null {
        info.type = a_info.type
    }
    var_type_repr := type_repr(info.type)
    if a_info != null {
        a_type_repr := type_repr(a_info.type)
        type_error := false
        if string.strlen(a_type_repr) != string.strlen(var_type_repr) {
            type_error = true
        } elif string.strcmp(a_type_repr, var_type_repr) != 0 {
            type_error = true
        }

        if type_error {
            chr* err_msg = (chr*) null
            io.asprintf(&err_msg, "cannot assign type '%s' to variable of type '%s'", a_type_repr, var_type_repr)
            new_error(ctx, stmt, err_msg)
        }
    }
    define_assignable(ctx, var_name.value, info)

    io.fprintf(ctx.ir, "%s = alloca %s\0A", repr_assignable_id(info), var_type_repr)
    if a_info != null {
        io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), repr_assignable_id(a_info), var_type_repr, repr_assignable_id(info))
    }
    return info
}

void compile_if_block(CompilerCtx* ctx, parser.Node* stmt) {

    assignable := skip_to_type(stmt.children, "assignable")
    a_info := compile_assignable(ctx, assignable)

    if_id := new_uid(ctx)
    io.fprintf(ctx.ir, "br %s %s, label %%.if.true.%d, label %%.if.false.%d\0A", type_repr(a_info.type), repr_assignable_id(a_info), if_id, if_id)
    io.fprintf(ctx.ir, ".if.true.%d:\0A", if_id)
    block := skip_to_type(stmt.children, "block")
    compile_block(ctx, block)
    io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
    io.fprintf(ctx.ir, ".if.false.%d:\0A", if_id)

    else_block := skip_to_type(stmt.children, "elif_block")
    if else_block != null {
        if string.strcmp(else_block.children.type, "else_block") == 0 {
            block = skip_to_type(else_block.children.children, "block")
            compile_block(ctx, block)
        } else {
            compile_if_block(ctx, else_block)
        }
    }

    -- compile any elif blocks
    io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
    io.fprintf(ctx.ir, ".if.end.%d:\0A", if_id)
}


void new_error(CompilerCtx* c, parser.Node* curr_node, str msg) {
    if curr_node != null {
        err := errors.new(curr_node.filename, curr_node.line, curr_node.char_of_line, msg)
        append_error(c, err)
    } else {
        sys.assert(false, "Programming error, unable to create new error from null node")
    }
}

-- binds the assignable to a given name in the current scope
void define_assignable(CompilerCtx* ctx, str name, AssignableInfo* info) {
    mod := get_current_module(ctx)
    sys.assert(mod.scopes != null, ":coffee-error: 'define_assignable' could not be called if context scopes are null")
    current_scope := mod.scopes

    -- check that assignable is not defined on this context
    -- for item := current_scope.item; item != null; item = item.next {
    -- }

    newitem := (ScopeItem*) sys.malloc(ScopeItem_size)
    newitem.name = name
    newitem.info = info
    newitem.next = null

    if current_scope.item == null {
        current_scope.item = newitem
        return
    }

    for last_item := current_scope.item; last_item.next != null; last_item = last_item.next {
    }
    last_item.next = newitem
}

AssignableInfo* find_defined_in(CompilerCtx* ctx, str module, parser.Node* dotted_name) {
    mod := get_module(ctx, module)
    sys.assert(mod.scopes != null, ":coffee-error: 'find_defined' could not be called if context scopes are null")

    assignable_name := dotted_name.value
    for s := mod.scopes; s != null; s = s.prev {
        for item := s.item; item != null; item = item.next {
            if string.strcmp(item.name, assignable_name) == 0 {
                return item.info
            }
        }
    }

    -- check global scopes, hmmmmmmm
    for g := ctx.globals; g != null; g = g.next {
        if string.strcmp(g.global_type, "string") != 0 {
            if string.strcmp(g.identifier, assignable_name) == 0 {
                return g.info
            }
        }
    }

    return (AssignableInfo*) null
}

-- returns the 'base' information of the dotted name
AssignableInfo* find_defined(CompilerCtx* ctx, parser.Node* dotted_name) {
    return find_defined_in(ctx, ctx.current_module, dotted_name.children)
}

AssignableInfo* get_dotted_name(CompilerCtx* c, parser.Node* dot_name_ptr, AssignableInfo* info) {
    chr* err_msg
    chr* buf

    if string.strcmp(info.name_type, "function") == 0 {
        -- got a function, cannot read dot names anymore
        if dot_name_ptr.next != null {
            io.asprintf(&err_msg, "cannot get attribute %s from function type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
        }
        return info
    } elif string.strcmp(info.name_type, "variable") == 0 & dot_name_ptr.next != null{
        if string.strcmp(info.type.container, "struct") != 0 {
            io.asprintf(&err_msg, "cannot get attribute %s from non struct type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
        }

        field_name := dot_name_ptr.next.next.value

        -- struct
        quit := false
        field_id := 0
        found_field := (Type*) null

        for field := info.type.of; quit == false; field = field.next {
            if field == null {
                quit = true
            } elif string.strcmp(field.info, field_name) == 0 {
                quit = true
                found_field = field
            } else {
                field_id = field_id + 1
            }
        }

        if found_field == null {
            io.asprintf(&err_msg, "field %s not defined in struct %s", field_name, dot_name_ptr.value)
            new_error(c, dot_name_ptr, err_msg)
            return (AssignableInfo*) null
        }

        new_info := new_assignable_info(dot_name_ptr)
        new_info.type = found_field

        set_assignable_tmp_id(c, new_info)
        new_info.name_type = "variable"

        info_tr := type_repr(info.type)
        io.fprintf(c.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\0A", repr_assignable_id(new_info), info_tr, info_tr, repr_assignable_id(info), field_id)

        return get_dotted_name(c, dot_name_ptr.next.next, new_info)

    } elif string.strcmp(info.name_type, "variable") == 0 {
        return info
    }

    io.printf(":coffee-error: `get_dotted_name` does not handle type: %s\0A", info.name_type)
    return (AssignableInfo*) null
}

-- returns address for node
AssignableInfo* compile_addr(CompilerCtx* ctx, parser.Node* curr_node) {
    chr* err_msg
    if string.strcmp(curr_node.type, "destination") != 0 {
        io.printf(":coffee-error: 'compile_addr' could only be called on destinations for now. (called on %s)\0A", curr_node.type)
        return (AssignableInfo*) null
    }

    -- type + id of addr
    assignable_name := curr_node.children
    info := find_defined(ctx, assignable_name)
    if info == null {
        -- error! name is not defined
        io.asprintf(&err_msg, "name '%s' is not defined\0A", assignable_name.children.value)
        new_error(ctx, curr_node, err_msg)
        return (AssignableInfo*) null
    }

    if string.strcmp(info.name_type, "module") == 0 {
        got := find_defined_in(ctx, repr_assignable_id(info), assignable_name.children.next.next)
        if info == null {
            io.asprintf(&err_msg, "name '%s' is not defined in %s", assignable_name.children.next.next.value, repr_assignable_id(info))
            new_error(ctx, curr_node, err_msg)
            return (AssignableInfo*) null
        }
        info = got
        assignable_name = assignable_name.children.next.next
    } else {
        assignable_name = assignable_name.children
    }

    base := get_dotted_name(ctx, assignable_name, info)

    -- node has a following square bracket, do something
    for addr := curr_node.children.next; addr != null; addr = addr.next.next.next {
        index := addr.next
        index_info := compile_assignable(ctx, index)

        base_type := type_repr(base.type)
        index_type := type_repr(index_info.type)

        tmp_id := new_uid(ctx)
        io.fprintf(ctx.ir, "%%.tmp%d = load %s, %s* %s\0A", tmp_id, base_type, base_type, repr_assignable_id(base))

        set_assignable_tmp_id(ctx, base)

        base.type = base.type.of
        base_type_2 := type_repr(base.type)

        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %%.tmp%d, %s %s\0A", repr_assignable_id(base), base_type_2, base_type_2, tmp_id, index_type, repr_assignable_id(index_info))

    }
    return base
}


alias StackHead = struct {
    sy.SYStack* h,
}
int StackHead_size = 8

AssignableInfo* compile_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    assignable_start := skip_to_type(curr_node.children, "mono_assignable")
    operator_stack := sy.sy_algorithm(assignable_start)

    stack := (StackHead*) sys.malloc(StackHead_size)
    stack.h = operator_stack

    info := compile_assignable_stack(ctx, stack)

    cast := skip_to_type(curr_node.children, "cast")
    if cast != null {
        cast_type := skip_to_type(cast.children, "type")

        new_type := node_to_type(ctx, cast_type.children)
        -- chr* new_id
        -- io.asprintf(&new_id, "%%.tmp%d", new_uid(ctx))
        prev_id := info.id
        set_assignable_tmp_id(ctx, info)

        io.fprintf(ctx.ir, "%s = bitcast %s %s to %s\0A", repr_assignable_id(info), type_repr(info.type), prev_id, type_repr(new_type))

        info.type = new_type
    }
    return info
}

AssignableInfo* compile_assignable_stack(CompilerCtx* ctx, StackHead* stack) {
    if string.strcmp(stack.h.n.type, "mono_assignable") == 0 {
        return compile_mono_assignable(ctx, stack.h.n)
    }
    operator := stack.h.n.children

    stack.h = stack.h.prev
    A := compile_assignable_stack(ctx, stack)

    stack.h = stack.h.prev
    B := compile_assignable_stack(ctx, stack)

    op_info := new_assignable_info((parser.Node*) null)
    op_info.type = operator_type(operator)

    -- op_id := new_uid(ctx)
    set_assignable_tmp_id(ctx, op_info)
    io.fprintf(ctx.ir, "%s = %s %s %s, %s\0A", repr_assignable_id(op_info), operator_op(ctx, operator), type_repr(A.type), repr_assignable_id(A), repr_assignable_id(B))

    return op_info
}

str operator_op(CompilerCtx* ctx, parser.Node* op) {
    if op == null {
        io.printf(":cofee-error: called 'operator_op' with null\0A")
    }

    if string.strcmp(op.value, "+") == 0 {
        return "add"
    } elif string.strcmp(op.value, "-") == 0 {
        return "sub"
    } elif string.strcmp(op.value, "*") == 0 {
        return "mul"
    } elif string.strcmp(op.value, "/") == 0 {
        return "sdiv"
    } elif string.strcmp(op.value, "==") == 0 {
        return "icmp eq"
    } elif string.strcmp(op.value, "!=") == 0 {
        return "icmp neq"
    } elif string.strcmp(op.value, ">") == 0 {
        return "icmp sgt"
    } elif string.strcmp(op.value, "<") == 0 {
        return "icmp slt"
    } elif string.strcmp(op.value, "&") == 0 {
        return "and"
    } elif string.strcmp(op.value, "|") == 0 {
        return "or"
    } else {
        io.printf(err_tmpl(ctx, op, "operator '%s' not implemented"), op.value)
    }
    return "add"
}

Type* operator_type(parser.Node* op) {
    type := (Type*) sys.malloc(Type_size)
    type.info = null
    type.of = null
    type.next = null
    if string.strcmp(op.value, "==") == 0 | string.strcmp(op.value, "!=") == 0 | string.strcmp(op.value, "|") == 0 | string.strcmp(op.value, "&") == 0 | string.strcmp(op.value, ">") == 0 | string.strcmp(op.value, "<") == 0 {
        type.container = "bool"
    } else {
        type.container = "int"
    }
    return type
}

AssignableInfo* compile_mono_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    AssignableInfo* assignable_info = (AssignableInfo*) null
    mono := curr_node
    chr* err_buf
    chr* buf

    if string.strcmp(mono.children.type, "NUMBER") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.of = null
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "int"
        set_assignable_id(assignable_info, SCOPE_CONST, mono.children.value)

    } elif string.strcmp(mono.children.type, "WORD") == 0 {
        if string.strcmp(mono.children.value, "null") != 0 {
            io.printf(":coffee-error: unable to interpret %s as mono_assignable\0A")
            return (AssignableInfo*) null
        }
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        set_assignable_id(assignable_info, SCOPE_CONST, "null")
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "nullptr"
        assignable_info.type.of = null

    } elif string.strcmp(mono.children.type, "addr_destination") == 0 {
        assignable_info = new_assignable_info(curr_node)
        dest := skip_to_type(mono.children.children, "destination")

        var_info := find_defined(ctx, dest.children)
        if var_info == null {
            io.asprintf(&err_buf, "Name %s is not defined in this scope", dest.children.children.value)
            new_error(ctx, curr_node, err_buf)
            return assignable_info
        }
        var_type_repr := type_repr(var_info.type)
        set_assignable_tmp_id(ctx, assignable_info)

        assignable_info.type = var_info.type
        for ptr := mono.children.children; ptr != dest; ptr = ptr.next {
            new_type := (Type*) sys.malloc(Type_size)
            new_type.of = assignable_info.type
            new_type.container = "ptr"
            new_type.next = null
            new_type.info = null

            assignable_info.type = new_type
        }

        if mono.children.children != dest {
            -- it's a pointer, load it's address
            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0\0A", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        } else {
            -- it's a variable, load it's content
            io.fprintf(ctx.ir, "%s = load %s, %s* %s\0A", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        }

    } elif string.strcmp(mono.children.type, "boolean") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.info = null
        assignable_info.type.of = null
        assignable_info.type.container = "bool"
        if string.strcmp(mono.children.children.value, "false") == 0 {
            set_assignable_id(assignable_info, SCOPE_CONST, "0")
        } else {
            set_assignable_id(assignable_info, SCOPE_CONST, "1")
        }
    } elif string.strcmp(mono.children.type, "fn_call") == 0 {
        assignable_info = compile_fn_call(ctx, mono.children.children)
    } elif string.strcmp(mono.children.type, "STRING") == 0 {
        string_info := define_string(ctx, mono.children.value) -- defines strings for future reuse, plus defines global functions or data structures when used
        assignable_info = new_assignable_info(curr_node)
        set_assignable_tmp_id(ctx, assignable_info)

        str_tr := type_repr(string_info.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s*%s, i32 0, i32 0\0A", repr_assignable_id(assignable_info), str_tr, str_tr, repr_assignable_id(string_info))

        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.info = null
        assignable_info.type.next = null
        assignable_info.type.container = "ptr"
        assignable_info.type.of = (Type*) sys.malloc(Type_size)
        assignable_info.type.of.info = null
        assignable_info.type.of.container = "chr"
        assignable_info.type.of.of = null
        assignable_info.type.of.next = null

    } elif string.strcmp(mono.children.type, "CHR") == 0 {
        assignable_info = new_assignable_info(curr_node)
        chr_len := string.strlen(mono.children.value)
        set_assignable_id(assignable_info, SCOPE_CONST, "0")

        intval := 0
        if chr_len == 5 {
            -- CHR in the form of "\XX" (hex numbers)
            io.sscanf(mono.children.value, "'\5C%x'", &intval)
            io.asprintf(&assignable_info.id, "%d", intval)

        } elif chr_len == 3 {
            -- CHR in the form of "X" (single character)
            io.sscanf(mono.children.value, "'%c'", &intval)
            io.asprintf(&assignable_info.id, "%d", intval)
        } else {
            -- malformed character
            io.asprintf(&err_buf, "Invalid character")
            new_error(ctx, mono, err_buf)
        }

        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.container = "chr"
        assignable_info.type.of = null
        assignable_info.type.info = null
        assignable_info.type.next = null
    } else {
        io.printf(":coffee-error: unable to compile assignable of type %s\0A", mono.children.type)
        return (AssignableInfo*) null
    }

    assignable_info.line = curr_node.line
    assignable_info.char_of_line = curr_node.char_of_line
    return (AssignableInfo*) assignable_info
}

str type_abbr(Type* type) {
    sys.assert(type != null, "called 'abbr' on null")
    sys.assert(type.container != null, "called 'type_abbr' with malformed type, container is null.")
    if string.strcmp(type.container, "int") == 0 {
        return "i"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "b"
    } elif string.strcmp(type.container, "void") == 0 {
        return "v"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "c"
    } elif string.strcmp(type.container, "str") == 0 {
        return "cp"
    } elif string.strcmp(type.container, "ptr") == 0 {
        chr* buf
        io.asprintf(&buf, "%sp", type_abbr(type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        return type.of.info
    } else {
        io.printf(":coffee-error: unable to abbreviate type %s", type.container)
    }
    return (chr*) null
}

AssignableInfo* define_string(CompilerCtx* ctx, str text) {
    info := new_assignable_info((parser.Node*) null)
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".str%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

    info.type = (Type*) sys.malloc(Type_size)
    info.type.info = null
    info.type.container = "array"
    info.type.of = (Type*) sys.malloc(Type_size)
    info.type.of.info = null
    info.type.of.container = "chr"
    info.type.of.of = null
    info.type.of.next = (Type*) sys.malloc(Type_size)
    info.type.of.next.info = null
    info.type.of.next.of = null
    io.asprintf(&info.type.of.next.container, "%d", string.strlen(text) -2 +1)

    global := (GlobalName*) sys.malloc(GlobalName_size)
    global.identifier = text
    global.global_type = "string"
    global.next = null
    global.info = info
    append_global(ctx, global)
    return info
}

GlobalName* define_typealias(CompilerCtx* ctx, AssignableInfo* typeinfo, str name) {
    global := (GlobalName*) sys.malloc(GlobalName_size)
    global.identifier = name
    global.global_type = "type"
    global.next = null
    global.info = typeinfo
    append_global(ctx, global)

    return global
}

void define_module(CompilerCtx* ctx, parser.Node* mod, str as_name, abspath) {
    g := (GlobalName*) sys.malloc(GlobalName_size)
    g.identifier = as_name
    g.global_type = "module"
    g.next = null

    g.info = new_assignable_info(mod)
    set_assignable_id(g.info, SCOPE_CONST, abspath)
    g.info.name_type = "module"
    g.info.type = null

    append_global(ctx, g)
}

void append_global(CompilerCtx* ctx, GlobalName* g) {
    if ctx.globals == null {
        ctx.globals = g
    } else {
        GlobalName* last_global
        for last_global = ctx.globals; last_global.next != null; last_global = last_global.next {
        }
        last_global.next = g
    }
}

str type_repr(Type* type) {
    sys.assert(type != null, "called 'type_repr' on null")
    sys.assert(type.container != null, "called 'type_repr' with malformed type, container is null.")
    chr* buf

    if string.strcmp(type.container, "int") == 0 {
        return "i32"
    } elif string.strcmp(type.container, "void") == 0 {
        return "void"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "i1"
    } elif string.strcmp(type.container, "nullptr") == 0 {
        return "ptr"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "i8"
    } elif string.strcmp(type.container, "function") == 0 {
        io.asprintf(&buf, "%s(", type_repr(type.of))
        for p := type.of.next; p != null; p = p.next {
            if p != type.of.next {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(p))
        }
        io.asprintf(&buf, "%s)", buf)
        return buf
    } elif string.strcmp(type.container, "ptr") == 0 {
        io.asprintf(&buf, "%s*", type_repr(type.of))
        return buf
    } elif string.strcmp(type.container, "struct") == 0 {
        -- io.asprintf(&buf, "{%s}", type_repr(type.of)
        io.asprintf(&buf, "{")
        for t := type.of; t != null; t = t.next {
            if t != type.of {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(t))
        }
        io.asprintf(&buf, "%s}", buf)
        return buf
    } elif string.strcmp(type.container, "array") == 0 {
        io.asprintf(&buf, "[%s x %s]", type.of.next.container, type_repr(type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        io.asprintf(&buf, "%%%s", type.of.info)
        return buf
    } elif string.strcmp(type.container, "str") == 0 {
        return "i8*"
    } elif string.strcmp(type.container, "vararg") == 0 {
        return "..."
    } else {
        io.printf(":coffee-error: 'type_repr' not implemented for type '%s'\0A", type.container)
    }

    return (chr*) null
}

void append_error(CompilerCtx* ctx, errors.Error* e) {
    new_err := (ErrorList*) sys.malloc(ErrorList_size)
    new_err.err = e
    new_err.next = null

    if ctx.errors == null {
        ctx.errors = new_err
        return
    }

    for last := ctx.errors; last.next != null ; last = last.next {
    }

    last.next = new_err
}

chr* syn_function_name(parser.Node* stmt) {
    return stmt.children.next.value
}
parser.Node* skip_to_type(parser.Node* node, str type) {
    for n := node; n != null; n = n.next {
        if string.strcmp(n.type, type) == 0 {
            return n
        }
    }
    return (parser.Node*) null
}


Type* syn_function_type(CompilerCtx* ctx, parser.Node* stmt) {
    function_type := (Type*) sys.malloc(Type_size)
    function_type.info = null

    return_value_type := node_to_type(ctx, stmt.children)
    function_type.container = "function"
    function_type.of = return_value_type

    last_type := return_value_type
    params := syn_function_params(stmt)

    for param_ptr := params; param_ptr != null ; {
        if string.strcmp(param_ptr.type, "WORD") == 0 {
            last_type.next = type_clone(last_type)
            last_type.next.next = null
            last_type = last_type.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next
            }
            if param_ptr.next != null {
                param_ptr = param_ptr.next
            } else {
                param_ptr = null
            }
        } else {
            param_type := node_to_type(ctx, param_ptr.children)
            last_type.next = param_type
            last_type = param_type
            param_ptr = param_ptr.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next.next
            } else {
                param_ptr = null
            }
        }
    }

    -- start parsing argument types
    return function_type
}

parser.Node* syn_function_params(parser.Node* stmt) {
    params := skip_to_type(stmt, "fn_params")
    if params == null {
        return (parser.Node*) null
    }
    return params.children
}

Type* node_to_type(CompilerCtx* ctx, parser.Node* stmt) {
    t := (Type*) sys.malloc(Type_size)
    t.of = null
    t.next = null
    t.info = null

    if string.strcmp(stmt.type, "structdef") == 0 {
        t.container = "struct"
        t.info = null

        curr_type := skip_to_type(stmt.children, "type")
        if curr_type != null {
            t.of = node_to_type(ctx, curr_type.children)
            t.of.info = curr_type.next.value

            curr_t := t.of
            for curr_type = skip_to_type(curr_type.next, "type"); curr_type != null; curr_type = skip_to_type(curr_type.next, "type") {
                curr_t.next = node_to_type(ctx, curr_type.children)
                curr_t.next.info = curr_type.next.value
                curr_t = curr_t.next
            }
        }
        -- parse struct fields
    } elif string.strcmp(stmt.type, "WORD") == 0 {
        t.container = stmt.value
    } elif string.strcmp(stmt.type, "dotted_name") == 0 {
        -- 1st resolve dotted name
        -- 2nd create type
        chr* err_msg
        base := find_defined(ctx, stmt)
        if base == null {
            io.asprintf(&err_msg, "Name %s is not defined in this scope", stmt.children.value)
            new_error(ctx, stmt, err_msg)
            t.container = "error"
            return t
        }

        if string.strcmp(base.name_type, "module") == 0 {
            base = find_defined_in(ctx, base.id, stmt.children.next.next)
            if base == null {
                io.asprintf(&err_msg, "Name %s is not defined in this scope", stmt.children.next.next.value)
                new_error(ctx, stmt.children.next.next, err_msg)
                t.container = "error"
                return t
            }
        }

        t.container = "typealias"
        t.of = (Type*) sys.malloc(Type_size)
        t.of.container = "alias"
        t.of.next = null
        t.of.info = base.id
    } elif string.strcmp(stmt.value, "...") == 0 {
        t.container = "vararg"
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to convert statement of type '%s' to type (%s)"), stmt.type, stmt.value)
    }

    for ptr := stmt.next; ptr != null; ptr = ptr.next {
        pt := (Type*) sys.malloc(Type_size)
        pt.container = "ptr"
        pt.of = t
        pt.next = null
        pt.info = null
        t = pt
    }

    return t
}
