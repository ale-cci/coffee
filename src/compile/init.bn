import "../std/sys" as sys
import "../std/io" as io
import "../syntax" as syntax
import "../parser" as parser
import "../std/string" as string
import "../peeker" as peeker
import "../lexer" as lexer
import "../std/ioutil" as ioutil

import "../parser.debug" as parser_debug
import "../errors" as errors
import "./shunting_yard" as sy
import "./llvm" as llvm

bool DEBUG_INTERNALS=false

alias ErrorList = struct {
    errors.Error* err,
    ErrorList* next,
}

alias Type = struct {
    chr* container,

    chr* info, -- extra info attached to this type entry (for struct field names)
    chr* repr,

    -- NOTE: each "basic" type is not allowed to have a 'next'
    -- value

    Type* of,
    Type* next,

    -- Type* of,
    -- chr* container,
}

Type* type_clone(Type* t) {
    if t == null {
        return (Type*) null
    }

    Type* clone = (Type*) sys.malloc(sizeof(Type))
    clone.of = t.of
    clone.next = type_clone(t.next)
    clone.repr = t.repr
    clone.container = t.container
    clone.info = t.info
    return clone
}
Type* new_type() {
    type := (Type*) sys.malloc(sizeof(Type))
    type.info = null
    type.repr = null
    type.container = null
    type.of = null
    type.next = null
    return type
}

void copy_type(Type* dest, Type* src) {
    dest.container = src.container
    dest.info = src.info
    dest.repr = src.repr

    if dest.of != src.of {
        dest.of = src.of
        copy_type(dest.of, src.of)
    }

    if dest.next != src.next {
        dest.next = src.next
        copy_type(dest.next, src.next)
    }
}

void debug_type(Type* t, int level) {
    chr* indent = (chr*) sys.malloc(level + 1)
    for i := 0 ; i < level; i = i + 1 {
        indent[i] = ' '
    }
    indent[level] = '\x00'

    io.printf("%s{\n", indent)
    io.printf(`%s  container: "%s"\n`, indent, t.container)
    io.printf(`%s  info: "%s"\n`, indent, t.info)
    io.printf(`%s  repr: "%s"\n`, indent, t.repr)
    if t.of == null {
        io.printf("%s  of: (null)\n", indent)
    } else {
        io.printf("%s  of: \n", indent)
        debug_type(t.of, level + 1)
    }
    if t.next == null {
        io.printf("%s  next: (null)\n", indent)
    } else {
        io.printf("%s  next: \n", indent)
        debug_type(t.next, level + 1)
    }
    io.printf("%s}\n", indent)
}

alias AssignableInfo = struct {
    -- uniquely identifies assignable
    chr* id,

    chr scope, -- adds @ before id if it's a global assignment, otherwise %
    chr* name_type,
    Type* type,

    -- where was the assignable defined
    int line,
    int char_of_line,
    chr* filename,
}

chr SCOPE_GLOBAL = '@'
chr SCOPE_LOCAL = '%'
chr SCOPE_CONST = ' '


AssignableInfo* new_assignable_info(parser.Node* node) {
    ptr := (AssignableInfo*) sys.malloc(sizeof(AssignableInfo))
    ptr.scope = SCOPE_CONST
    ptr.id = null
    ptr.name_type = null
    ptr.type = null

    -- copy line and char of line from specified node
    if node != null {
        ptr.line = node.line
        ptr.char_of_line = node.char_of_line
        ptr.filename = node.filename
    } else {
        ptr.line = 0
        ptr.char_of_line = 0
        ptr.filename = null
    }
    return ptr
}

void set_assignable_id(AssignableInfo* info, chr scope, chr* id) {
    info.id = id
    info.scope = scope
}

chr* repr_assignable_id(AssignableInfo* info) {
    if info.scope == SCOPE_CONST {
        return info.id
    }
    chr* buf
    io.asprintf(&buf, "%c%s", info.scope, info.id)
    return buf
}


alias ScopeItem = struct {
    chr* name,
    AssignableInfo* info,
    ScopeItem* next,
}

alias GlobalName = struct {
    chr* identifier,

    chr* global_type, -- string, typealias, module
    bool compiled,
    AssignableInfo* info,
    GlobalName* next,
}

alias Scope = struct {
    chr* filename,
    ScopeItem* item,
    Scope* prev,
}

alias ModuleLookup = struct {
    chr* abspath,
    chr* prefix,
    ModuleLookup* next,
    Scope* scopes,
}
int ModuleLookup_size = 32


alias CompilerCtx = struct {
    parser.Node* root,
    io.File* ir,
    ErrorList* errors,
    GlobalName* globals,
    int counter,
    ModuleLookup* modules,
    chr* current_module,
}

void set_assignable_tmp_id(CompilerCtx* ctx, AssignableInfo* info) {
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".tmp%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_LOCAL, tmp_buff)
}

ModuleLookup* get_module(CompilerCtx* ctx, str filename) {
    for m := ctx.modules; m != null; m = m.next {
        if string.strcmp(m.abspath, filename) == 0 {
            return m
        }
    }
    return (ModuleLookup*) null
}
ModuleLookup* get_current_module(CompilerCtx* ctx) {
    return get_module(ctx, ctx.current_module)
}

int new_uid(CompilerCtx* ctx) {
    uid := ctx.counter
    ctx.counter = ctx.counter + 1
    return uid
}

CompilerCtx* new_context(io.File* fd, str filename) {
    CompilerCtx* ctx = (CompilerCtx*) sys.malloc(sizeof(CompilerCtx))
    ctx.ir = fd
    ctx.root = (parser.Node*) null
    ctx.errors = null
    ctx.counter = 0
    ctx.globals = null
    ctx.current_module = filename

    ctx.modules = (ModuleLookup*) sys.malloc(ModuleLookup_size)
    ctx.modules.abspath = filename -- TODO: add initial filename here
    ctx.modules.scopes = null
    ctx.modules.prefix = ""
    ctx.modules.next = null

    return (CompilerCtx*) ctx
}

void push_scope(CompilerCtx* ctx) {
    s := (Scope*) sys.malloc(sizeof(Scope))

    m := get_current_module(ctx)
    s.prev = m.scopes
    s.item = null
    m.scopes = s
}
void pop_scope(CompilerCtx* ctx) {
    -- TODO: free this scope -> s := ctx.scopes
    m := get_current_module(ctx)
    sys.assert(m.scopes != null, ":coffee-error: 'pop_scope' called when module.scopes is null")
    m.scopes = m.scopes.prev
}


bool compile_file(CompilerCtx* ctx, str filepath) {
    grammar_file := ioutil.str_as_file(syntax.grammar())
    if grammar_file == null {
        return false
    }
    grammar_ctx := parser.new_context(grammar_file)
    grammar := parser.parse_grammar(grammar_ctx)
    sys.free((chr*) grammar_ctx)

    int input_fd = io.open(filepath, io.O_RDONLY)

    p := peeker.new(input_fd)
    p.filename = filepath

    tokens := lexer.tokenize(p, false)
    ast := parser.ast(grammar, "start", tokens)
    return compile(ctx, ast.node)
}


bool compile(CompilerCtx* ctx, parser.Node* ast) {
    if string.strcmp(ast.type, "start") != 0 {
        return false
    }

    -- push global context scope
    push_scope(ctx)

    start := ast.children
    if string.strcmp(start.type, "head_comment") == 0 {
        start = start.next
    }
    -- todo: pre-parse 'extern', 'function', 'globals'
    for stmt := start; stmt != null; stmt = stmt.next {
        compile_statement(ctx, stmt.children, true)
    }

    for s := start; s != null; s = s.next {
        compile_statement(ctx, s.children, false)
    }
    has_errors := ctx.errors != null
    for err := ctx.errors; err != null; err = err.next {
        errors.report(err.err)
    }


    -- add globals
    for g := ctx.globals; g != null; g = g.next {
        compile_global(ctx, g)
    }

    -- TODO: free errors
    return has_errors
}

void compile_global(CompilerCtx* ctx, GlobalName* g) {
    if g.compiled == false & string.strcmp(g.global_type, "string") == 0 {
        io.fprintf(ctx.ir, "%s = constant %s %s\n", repr_assignable_id(g.info), type_repr(ctx, g.info.type), g.identifier)
        g.compiled = true
    }
}


chr* get_mod_prefix(CompilerCtx* ctx, str module_abspath) {
    m := get_current_module(ctx)
    return m.prefix
}


str name_mangle(CompilerCtx* ctx, parser.Node* fn, str original_name, Type* type) {
    chr* mangled_name

    chr* prefix = get_mod_prefix(ctx, fn.filename)
    io.asprintf(&mangled_name, "%s%s", prefix, original_name)
    if string.strcmp(type.container, "function") == 0 {
        -- function  name is the concatenation of module, original name
        -- return value and parameters type
        if string.strcmp(mangled_name, "main") != 0 {
            chr* tmp_buff
            chr* swap_var
            for tp := type.of; tp != null; tp = tp.next {
                io.asprintf(&tmp_buff, "%s.%s", mangled_name, type_abbr(tp))

                swap_var = tmp_buff
                tmp_buff = mangled_name
                mangled_name = swap_var
                sys.free(tmp_buff)
            }
        }
    }

    return mangled_name
}

void compile_statement(CompilerCtx* ctx, parser.Node* stmt, bool shallow) {
    AssignableInfo* info
    Type* return_type
    chr* err_buf
    chr* tmp_buff

    if string.strcmp(stmt.type, "NL") == 0 {
        return
    } elif string.strcmp(stmt.type, "global") == 0 {
        assignable := skip_to_type(stmt.children, "assignable")
        a_info := compile_assignable(ctx, assignable)
        if a_info == null {
            return
        }

        info = new_assignable_info(stmt)
        global_name := stmt.children.next.value
        set_assignable_id(info, SCOPE_GLOBAL, global_name)
        info.type = a_info.type
        info.name_type = "variable"

        if shallow == true {
            define_assignable(ctx, global_name, info)
        } else {
            io.fprintf(ctx.ir, "%s = constant %s %s\n", repr_assignable_id(info), type_repr(ctx, info.type), repr_assignable_id(a_info))
        }

    } elif string.strcmp(stmt.type, "typealias") == 0 {

        type_name := stmt.children.next.value

        if shallow == true {
            info = new_assignable_info(stmt)
            mod_from := get_current_module(ctx)
            io.asprintf(&tmp_buff, "%s.%s.type", mod_from.prefix, type_name)
            set_assignable_id(info, SCOPE_LOCAL, tmp_buff)

            info.name_type = "typealias"
            info.line = stmt.line
            info.char_of_line = stmt.char_of_line
            info.type = new_type()

            define_assignable(ctx, type_name, info)

            type_decl := skip_to_type(stmt.children, "type")
            type_struct := node_to_type(ctx, type_decl.children)

            copy_type(info.type, type_struct)
            info.type = type_struct

            -- debug_type(info.type, 0)
        } else {
            scope := find_defined_str(ctx, ctx.current_module, type_name)
            info = scope.info
            io.fprintf(ctx.ir, "%s = type %s\n", repr_assignable_id(info), type_repr(ctx, info.type))
        }

    } elif string.strcmp(stmt.type, "extern") == 0 {
        info = new_assignable_info(stmt)
        info.type = syn_function_type(ctx, stmt.children.next)
        info.name_type = "extern"

        fn_name := stmt.children.next.next.value
        set_assignable_id(info, SCOPE_GLOBAL, fn_name)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        -- copy defined function return type
        return_type = (Type*) sys.malloc(sizeof(Type))
        return_type.next = null
        return_type.info = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        if shallow == false {
            io.fprintf(ctx.ir, "declare %s %s(", type_repr(ctx, return_type), repr_assignable_id(info))
            for pt := info.type.of.next; pt != null; pt = pt.next {
                if pt != info.type.of.next {
                    io.fprintf(ctx.ir, ", ")
                }
                io.fprintf(ctx.ir, "%s", type_repr(ctx, pt))
            }

            io.fprintf(ctx.ir, ")\n")
            sys.free((chr*) return_type)
        } else {
            define_assignable(ctx, fn_name, info)
        }

    } elif string.strcmp(stmt.type, "function") == 0 {
        -- function definition
        info = new_assignable_info(stmt)
        info.name_type = "function"
        info.type = syn_function_type(ctx, stmt.children)

        name := syn_function_name(stmt)
        tmp_buff = name_mangle(ctx, stmt, name, info.type)
        set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

        if shallow == true {
            define_assignable(ctx, name, info)
        } else {

            -- copy defined function return type
            return_type = new_type()
            copy_type(return_type, info.type.of)


            io.fprintf(ctx.ir, "define %s %s(", type_repr(ctx, return_type), repr_assignable_id(info))
            params := syn_function_params(stmt.children)

            Type* param_type
            for param_ptr := params; param_ptr != null ; {
                if param_ptr != params {
                    param_ptr = param_ptr.next
                    io.fprintf(ctx.ir, ", ")
                }
                if string.strcmp(param_ptr.type, "type") == 0 {
                    param_type = node_to_type(ctx, param_ptr.children)
                    param_ptr = param_ptr.next
                }
                io.fprintf(ctx.ir, "%s %%.%s.arg", type_repr(ctx, param_type), param_ptr.value)
                param_ptr = param_ptr.next
            }
            -- build function parameters string
            io.fprintf(ctx.ir, ") {\n")
            push_scope(ctx)
            compile_fn_params(ctx, params)

            fn_block := skip_to_type(stmt.children, "block")
            compile_block(ctx, fn_block)
            pop_scope(ctx)


            parser.Node* last_valid_instruction = (parser.Node*) null

            -- check if last instruction is a return stmt
            -- otherwise add implicit void return
            -- or signal an error
            for ci := fn_block.children; ci.next != null; ci = ci.next {
                if string.strcmp(ci.type, "NL") != 0 & string.strcmp(ci.type, "OPERATOR") != 0 {
                    last_valid_instruction = ci
                }
            }

            add_implicit_return := false
            if last_valid_instruction == null {
                add_implicit_return = true
            } elif string.strcmp(last_valid_instruction.children.type, "return") != 0 {
                add_implicit_return = true
            }

            if add_implicit_return {
                if string.strcmp(type_repr(ctx, return_type), "void") != 0 {
                    new_error(ctx, fn_block, "missing return value")
                } else {
                    io.fprintf(ctx.ir, "ret void\n")
                }
            }

            io.fprintf(ctx.ir, "}\n")
        }

    } elif string.strcmp(stmt.type, "import") == 0 {
        if shallow == true {
            -- 1. get file cwd
            -- check if module is already imported in module lookup
            mod_name := stmt.children.next.value
            mod_abspath := ctx.current_module

            dirname := sys.dirname(mod_abspath)

            mod_name_len := string.strlen(mod_name)
            trimmed_name := sys.malloc(mod_name_len -1)
            for i := 1 ; i < mod_name_len - 1; i = i + 1 {
                trimmed_name[i - 1] = mod_name[i]
            }
            trimmed_name[mod_name_len -2] = '\x00'
            if string.strcmp(dirname, "") == 0 {
                io.asprintf(&mod_abspath, "%s.bn", trimmed_name)
            } else {
                io.asprintf(&mod_abspath, "%s/%s.bn", dirname, trimmed_name)
            }
            mod_abspath = sys.realpath(mod_abspath, sys.malloc(4096))

            if mod_abspath == null {
                io.asprintf(&err_buf, "Unable to import '%s' no such file or directory. (%s/%s.bn)", mod_name, dirname, trimmed_name)
                new_error(ctx, stmt, err_buf)
                return
            }

            -- define module lookup if not found

            already_imported := false
            ModuleLookup* m
            ModuleLookup* mod = (ModuleLookup*) null

            for m = ctx.modules; m != null & mod == null; m = m.next {
                if string.strcmp(mod_abspath, m.abspath) == 0 {
                    mod = m
                }
            }

            asname := stmt.children.next.next.next.value

            if mod == null {
                mod = (ModuleLookup*) sys.malloc(ModuleLookup_size)
                mod.abspath = mod_abspath
                mod.next = null
                mod.scopes = null
                io.asprintf(&mod.prefix, "m%d$", new_uid(ctx))

                for m = ctx.modules; m.next != null; m = m.next {
                }
                m.next = mod

                define_module(ctx, stmt, asname, mod.abspath)

                curr_mod := ctx.current_module
                ctx.current_module = mod.abspath
                compile_file(ctx, mod.abspath)
                ctx.current_module = curr_mod
            } else {
                define_module(ctx, stmt, asname, mod.abspath)
            }
        }
    } else {
        io.printf(err_tmpl(ctx, stmt, "statement of type %s is not implemented"), stmt.type)
    }
}

chr* err_tmpl(CompilerCtx* ctx, parser.Node* stmt, chr* msg) {
    chr* buf
    io.asprintf(&buf, ":coffee-error: (%s: %d:%d) %s\n", ctx.current_module, stmt.line, stmt.char_of_line, msg)
    return buf
}

void compile_fn_params(CompilerCtx* ctx, parser.Node* fn_params) {
    Type* param_type
    for param_ptr := fn_params; param_ptr != null ; {
        if param_ptr != fn_params {
            param_ptr = param_ptr.next
        }

        param_info := new_assignable_info(fn_params)
        param_info.name_type = "variable"
        if string.strcmp(param_ptr.type, "type") == 0 {
            param_type = node_to_type(ctx, param_ptr.children)
            param_ptr = param_ptr.next
        }
        param_info.type = param_type

        var_name := param_ptr.value
        set_assignable_id(param_info, SCOPE_LOCAL, var_name)

        param_info_tr := type_repr(ctx, param_info.type)
        io.fprintf(ctx.ir, "%s = alloca %s\n", repr_assignable_id(param_info), param_info_tr)
        define_assignable(ctx, var_name, param_info)
        io.fprintf(ctx.ir, "store %s %%.%s.arg, %s* %s\n", param_info_tr, var_name, param_info_tr, repr_assignable_id(param_info))
        param_ptr = param_ptr.next
    }
}


void compile_block(CompilerCtx* ctx, parser.Node* stmt) {
    push_scope(ctx)
    -- parse only expressions
    for b := stmt.children; b != null ; b = b.next {
        if string.strcmp(b.type, "expression") == 0 {
            compile_expression(ctx, b.children)
        }
    }
    pop_scope(ctx)
}

AssignableInfo* compile_builtin(CompilerCtx* ctx, parser.Node* stmt) {
    dotted := stmt.children.children
    if dotted.next != null {
        return (AssignableInfo*) null
    }

    if string.strcmp(dotted.value, "sizeof") == 0 {
        args := skip_to_type(stmt, "fn_args")
        value := skip_to_type(args.children, "assignable")
        value = value.children.children.children.children
        tmp_id := new_uid(ctx)

        info := new_assignable_info(stmt)
        set_assignable_tmp_id(ctx, info)

        info.type = new_type()
        info.type.container = "int"

        inspected_type := node_to_type(ctx, value)
        type_as_str := type_repr(ctx, inspected_type)

        io.fprintf(ctx.ir, "%%.tmp%d = getelementptr %s, %s* null, i32 1\n", tmp_id, type_as_str, type_as_str)
        io.fprintf(ctx.ir, "%s = ptrtoint %s* %%.tmp%d to i32\n", repr_assignable_id(info), type_as_str, tmp_id)


        return info
    }

    return (AssignableInfo*) null
}

AssignableInfo* compile_fn_call(CompilerCtx* ctx, parser.Node* stmt) {
    info := compile_builtin(ctx, stmt)
    if info != null {
        return info
    }
    info = compile_addr(ctx, stmt)
    if info == null {
        -- error
        if DEBUG_INTERNALS {
            io.printf(err_tmpl(ctx, stmt, "unable to compile function address"))
        }
        return (AssignableInfo*) null
    }

    args := skip_to_type(stmt, "fn_args")
    chr* params_buff = ""
    chr* tmp
    if args != null {
        start := skip_to_type(args.children, "assignable")
        for pp := start; pp != null; pp = skip_to_type(pp, "assignable") {
            if pp != start {
                io.asprintf(&tmp, "%s, ", params_buff)
                chr* tmp_buff = params_buff
                params_buff = tmp
                tmp = tmp_buff
                sys.free(tmp)
            }
            a_info := compile_assignable(ctx, pp)
            if a_info == null {
                return (AssignableInfo*) null
            }
            io.asprintf(&params_buff, "%s%s %s", params_buff, type_repr(ctx, a_info.type), repr_assignable_id(a_info))
            pp = pp.next
        }
    }


    if string.strcmp(type_repr(ctx, info.type.of), "void") == 0 {
        io.fprintf(ctx.ir, "call %s %s(%s)\n", type_repr(ctx, info.type), repr_assignable_id(info), params_buff)
        return (AssignableInfo*) null
    }

    call_info := new_assignable_info(stmt)
    set_assignable_tmp_id(ctx, call_info)
    call_info.type = type_clone(info.type.of)
    call_info.type.next = null

    io.fprintf(ctx.ir, "%s = call %s %s(%s)\n", repr_assignable_id(call_info), type_repr(ctx, info.type), repr_assignable_id(info), params_buff)

    return (AssignableInfo*) call_info
}

void compile_expression(CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg
    expr_type := stmt.type

    AssignableInfo* info = (AssignableInfo*) null
    parser.Node* assignable
    AssignableInfo* a_info = (AssignableInfo*) null

    if string.strcmp(expr_type, "return") == 0 {
        if string.strcmp(stmt.children.next.type, "NL") != 0 {
            info = compile_assignable(ctx, stmt.children.next)
            if info == null {
                return
            }
            io.fprintf(ctx.ir, "ret %s %s\n", type_repr(ctx, info.type), repr_assignable_id(info))
        } else {
            io.fprintf(ctx.ir, "ret void\n")
        }

    } elif string.strcmp(expr_type, "NL") == 0 {
        -- skip empty newlines
    } elif string.strcmp(expr_type, "fn_call") == 0 {
        compile_fn_call(ctx, stmt.children)
    } elif string.strcmp(expr_type, "declaration") == 0 {
        compile_declaration(ctx, stmt)
    } elif string.strcmp(expr_type, "assignment") == 0 {
        assignable = skip_to_type(stmt.children, "assignable")
        dest := compile_addr(ctx, stmt.children)
        if dest == null {
            io.asprintf(&err_msg, "%s was not declared in this scope", stmt.children.children.children.value)
            new_error(ctx, stmt, err_msg)
            return
        }
        a_info = compile_assignable(ctx, assignable)
        if a_info == null {
            return
        }

        dest_tr := type_repr(ctx, dest.type)
        chr* src_tr = type_repr(ctx, a_info.type)
        if string.strcmp(src_tr, "ptr") == 0 {
            src_tr = dest_tr
        }
        io.fprintf(ctx.ir, "store %s %s, %s* %s\n", src_tr, repr_assignable_id(a_info), dest_tr, repr_assignable_id(dest))
    } elif string.strcmp(expr_type, "if_block") == 0 {
        compile_if_block(ctx, stmt)
    } elif string.strcmp(expr_type, "for_loop") == 0 {
        compile_for_loop(ctx, stmt)
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to compile expression '%s'"), expr_type)
    }
}

void compile_for_loop(CompilerCtx* ctx, parser.Node* stmt) {
    for_id := new_uid(ctx)
    init_stmt := stmt.children.next

    if string.strcmp(init_stmt.type, "declaration") == 0 {
        compile_declaration(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "assignment") == 0 {
        compile_expression(ctx, init_stmt)
    } elif string.strcmp(init_stmt.type, "OPERATOR") == 0 {
        -- no init condition provided
    } else {
        -- coffee error
        io.printf(err_tmpl(ctx, init_stmt, "unable to compile statement of type %s in for loop init condition"), init_stmt.type)
        return
    }

    io.fprintf(ctx.ir, "br label %%.for.start.%d\n", for_id)
    io.fprintf(ctx.ir, ".for.start.%d:\n", for_id)

    -- check for 'for' condition
    fst_colon := skip_to_type(stmt.children, "OPERATOR")
    condition := fst_colon.next
    condition_info := compile_assignable(ctx, condition)
    io.fprintf(ctx.ir, "br %s %s, label %%.for.continue.%d, label %%.for.end.%d\n", type_repr(ctx, condition_info.type), repr_assignable_id(condition_info), for_id, for_id)

    io.fprintf(ctx.ir, ".for.continue.%d:\n", for_id)

    -- compile body

    snd_colon := skip_to_type(fst_colon.next, "OPERATOR")
    increment := snd_colon.next

    for_body := skip_to_type(snd_colon, "block")
    compile_block(ctx, for_body)

    -- compile increment statement only if it exists
    if increment != for_body {
        compile_expression(ctx, increment)
    }

    -- execute for increment before next loop
    io.fprintf(ctx.ir, "br label %%.for.start.%d\n", for_id)
    io.fprintf(ctx.ir, ".for.end.%d:\n", for_id)
}

AssignableInfo* compile_declaration(CompilerCtx* ctx, parser.Node* stmt) {
    Type* decl_type = (Type*) null
    AssignableInfo* a_info = (AssignableInfo*) null

    -- explicit declaration: detect variable type from starting 'type' node
    if string.strcmp(stmt.children.type, "type") == 0 {
        decl_type = node_to_type(ctx, stmt.children.children)
    }

    assignable := skip_to_type(stmt.children, "assignable")

    if assignable != null {
        a_info = compile_assignable(ctx, assignable)
    }

    info := new_assignable_info(stmt)
    info.name_type = "variable"
    var_name := skip_to_type(stmt.children, "WORD")

    if var_name == null {
        io.printf(err_tmpl(ctx, stmt, "unable to get declaration name"))
        return (AssignableInfo*) null
    }

    set_assignable_id(info, SCOPE_LOCAL, var_name.value)

    if decl_type != null {
        info.type = decl_type
    } elif a_info != null {
        info.type = a_info.type
    }
    var_type_repr := type_repr(ctx, info.type)
    if a_info != null {
        a_type_repr := type_repr(ctx, a_info.type)
        type_error := false
        if string.strlen(a_type_repr) != string.strlen(var_type_repr) {
            type_error = true
        } elif string.strcmp(a_type_repr, var_type_repr) != 0 {
            type_error = true
        }

        if type_error {
            chr* err_msg = (chr*) null
            io.asprintf(&err_msg, "cannot assign type '%s' to variable of type '%s'", a_type_repr, var_type_repr)
            new_error(ctx, stmt, err_msg)
        }
    }
    define_assignable(ctx, var_name.value, info)

    io.fprintf(ctx.ir, "%s = alloca %s\n", repr_assignable_id(info), var_type_repr)
    if a_info != null {
        io.fprintf(ctx.ir, "store %s %s, %s* %s\n", type_repr(ctx, a_info.type), repr_assignable_id(a_info), var_type_repr, repr_assignable_id(info))
    }
    return info
}

void compile_if_block(CompilerCtx* ctx, parser.Node* stmt) {

    assignable := skip_to_type(stmt.children, "assignable")
    a_info := compile_assignable(ctx, assignable)
    if a_info == null {
        return
    }

    if_id := new_uid(ctx)
    io.fprintf(ctx.ir, "br %s %s, label %%.if.true.%d, label %%.if.false.%d\n", type_repr(ctx, a_info.type), repr_assignable_id(a_info), if_id, if_id)
    io.fprintf(ctx.ir, ".if.true.%d:\n", if_id)
    block := skip_to_type(stmt.children, "block")
    compile_block(ctx, block)
    io.fprintf(ctx.ir, "br label %%.if.end.%d\n", if_id)
    io.fprintf(ctx.ir, ".if.false.%d:\n", if_id)

    else_block := skip_to_type(stmt.children, "elif_block")
    if else_block != null {
        if string.strcmp(else_block.children.type, "else_block") == 0 {
            block = skip_to_type(else_block.children.children, "block")
            compile_block(ctx, block)
        } else {
            compile_if_block(ctx, else_block)
        }
    }

    -- compile any elif blocks
    io.fprintf(ctx.ir, "br label %%.if.end.%d\n", if_id)
    io.fprintf(ctx.ir, ".if.end.%d:\n", if_id)
}


void new_error(CompilerCtx* ctx, parser.Node* curr_node, str msg) {
    if curr_node != null {
        err := errors.new(ctx.current_module, curr_node.line, curr_node.char_of_line, msg)
        append_error(ctx, err)
    } else {
        sys.assert(false, "Programming error, unable to create new error from null node")
    }
}

-- binds the assignable to a given name in the current scope
void define_assignable(CompilerCtx* ctx, str name, AssignableInfo* info) {
    mod := get_current_module(ctx)
    sys.assert(mod.scopes != null, ":coffee-error: 'define_assignable' could not be called if context scopes are null")
    current_scope := mod.scopes

    -- check that assignable is not defined on this context
    -- for item := current_scope.item; item != null; item = item.next {
    -- }

    newitem := (ScopeItem*) sys.malloc(sizeof(ScopeItem))
    newitem.name = name
    newitem.info = info
    newitem.next = null

    if current_scope.item == null {
        current_scope.item = newitem
        return
    }

    last_item := current_scope.item
    for ; last_item.next != null; last_item = last_item.next {
    }
    last_item.next = newitem
}

ScopeItem* find_defined_in(CompilerCtx* ctx, str module, parser.Node* dotted_name) {
    chr* err_buf

    found := find_defined_str(ctx, module, dotted_name.value)
    if found == null {
        io.asprintf(&err_buf, "Name %s not found in module %s", dotted_name.value, module)
        new_error(ctx, dotted_name, err_buf)
        return (ScopeItem*) null
    }

    for ; dotted_name.next != null & string.strcmp(found.info.name_type, "module") == 0 ; {
        found = find_defined_in(ctx, found.info.id, dotted_name.next.next)

        if found == null {
            return (ScopeItem*) null
        }
    }

    return found
}

ScopeItem* find_defined_str(CompilerCtx* ctx, str module, str assignable_name) {
    mod := get_module(ctx, module)
    sys.assert(mod.scopes != null, ":coffee-error: 'find_defined' could not be called if context scopes are null")


    for s := mod.scopes; s != null; s = s.prev {
        for item := s.item; item != null; item = item.next {
            if string.strcmp(item.name, assignable_name) == 0 {
                return item
            }
        }
    }

    return (ScopeItem*) null
}

-- returns the 'base' information of the dotted name
ScopeItem* find_defined(CompilerCtx* ctx, parser.Node* dotted_name) {
    return find_defined_in(ctx, ctx.current_module, dotted_name.children)
}


AssignableInfo* get_dotted_name(CompilerCtx* ctx, parser.Node* dot_name_ptr, AssignableInfo* info) {
    chr* err_msg
    chr* buf

    if info == null {
        io.printf(err_tmpl(ctx, dot_name_ptr, "cannot call 'get_dotted_name' on null assignable info"))
        return (AssignableInfo*) null
    }

    if string.strcmp(info.name_type, "function") == 0 | string.strcmp(info.name_type, "extern") == 0 {
        -- got a function, cannot read dot names anymore
        if dot_name_ptr.next != null {
            io.asprintf(&err_msg, "cannot get attribute %s from function type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (AssignableInfo*) null
        }
        return info
    } elif string.strcmp(info.name_type, "variable") == 0 & dot_name_ptr.next != null {
        base_var := info

        struct_info := base_var.type

        -- auto-dereference variable
        for ; string.strcmp(base_var.type.container, "ptr") == 0 ; {
            new_base := new_assignable_info(dot_name_ptr)
            set_assignable_tmp_id(ctx, new_base)
            new_base.type = base_var.type.of

            io.fprintf(ctx.ir, "%s = load %s*, %s* %s\n", repr_assignable_id(new_base), type_repr(ctx, new_base.type), type_repr(ctx, base_var.type), repr_assignable_id(base_var))
            base_var = new_base

            struct_info = struct_info.of
        }

        if string.strcmp(struct_info.container, "typealias") == 0 {
            struct_info = struct_info.of
        }

        if string.strcmp(struct_info.container, "struct") != 0 {
            io.asprintf(&err_msg, "cannot get attribute %s from non struct type %s", dot_name_ptr.next.next.value, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (AssignableInfo*) null
        }

        field_name := dot_name_ptr.next.next.value

        -- struct
        quit := false
        field_id := 0
        found_field := (Type*) null

        -- here, from a struct i'm extracting the value of the field.
        for field := struct_info.of; quit == false; field = field.next {
            if field == null {
                quit = true
            } elif string.strcmp(field.info, field_name) == 0 {
                quit = true
                found_field = field
            } else {
                field_id = field_id + 1
            }
        }

        if found_field == null {
            io.asprintf(&err_msg, "field %s not defined in struct %s", field_name, dot_name_ptr.value)
            new_error(ctx, dot_name_ptr, err_msg)
            return (AssignableInfo*) null
        }

        new_info := new_assignable_info(dot_name_ptr)
        new_info.type = found_field

        set_assignable_tmp_id(ctx, new_info)
        new_info.name_type = "variable"

        info_tr := type_repr(ctx, base_var.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0, i32 %d\n", repr_assignable_id(new_info), info_tr, info_tr, repr_assignable_id(base_var), field_id)

        return get_dotted_name(ctx, dot_name_ptr.next.next, new_info)

    } elif string.strcmp(info.name_type, "variable") == 0 {
        return info
    }

    io.printf(err_tmpl(ctx, dot_name_ptr, "`get_dotted_name` does not handle type: %s"), info.name_type)
    return (AssignableInfo*) null
}

-- returns address for node
AssignableInfo* compile_addr(CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg

    curr_node := stmt
    if string.strcmp(curr_node.type, "destination") != 0 {
        io.printf(":coffee-error: 'compile_addr' could only be called on destinations for now. (called on %s)\n", curr_node.type)
        -- return (AssignableInfo*) null
        curr_node = stmt.children
    }
    -- extract the destination

    -- type + id of addr
    assignable_name := curr_node.children
    scope_info := find_defined_str(ctx, ctx.current_module, assignable_name.children.value)
    if scope_info == null {
        -- error! name is not defined
        io.asprintf(&err_msg, "name '%s' is not defined", assignable_name.children.value)
        new_error(ctx, assignable_name, err_msg)
        return (AssignableInfo*) null
    }
    info := scope_info.info

    if string.strcmp(info.name_type, "module") == 0 {
        scope_info = find_defined_str(ctx, repr_assignable_id(info), assignable_name.children.next.next.value)
        if scope_info == null {
            io.asprintf(&err_msg, "name '%s' is not defined in %s", assignable_name.children.next.next.value, repr_assignable_id(info))
            new_error(ctx, curr_node, err_msg)
            return (AssignableInfo*) null
        }
        info = scope_info.info
        assignable_name = assignable_name.children.next.next
    } else {
        assignable_name = assignable_name.children
    }

    base := get_dotted_name(ctx, assignable_name, info)

    -- node has a following square bracket, do something

    for addr := curr_node.children.next; addr != null; addr = addr.next.next.next {
        index := addr.next
        index_info := compile_assignable(ctx, index)

        base_type := type_repr(ctx, base.type)
        index_type := type_repr(ctx, index_info.type)

        tmp_id := new_uid(ctx)
        io.fprintf(ctx.ir, "%%.tmp%d = load %s, %s* %s\n", tmp_id, base_type, base_type, repr_assignable_id(base))

        new_base := new_assignable_info(curr_node)
        set_assignable_tmp_id(ctx, new_base)

        if base.type.of == null {
            io.asprintf(&err_msg, "Unable to get address for type: %s", base_type)
            new_error(ctx, addr, err_msg)
            return base
        }

        new_base.type = base.type.of
        base_type_2 := type_repr(ctx, new_base.type)

        io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %%.tmp%d, %s %s\n", repr_assignable_id(new_base), base_type_2, base_type_2, tmp_id, index_type, repr_assignable_id(index_info))

        base = new_base
    }

    -- extract address if it's a destination
    return base
}


alias StackHead = struct {
    sy.SYStack* h,
}

AssignableInfo* compile_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    assignable_start := skip_to_type(curr_node.children, "mono_assignable")
    operator_stack := sy.sy_algorithm(assignable_start)

    stack := (StackHead*) sys.malloc(sizeof(StackHead))
    stack.h = operator_stack

    info := compile_assignable_stack(ctx, stack)
    if info == null {
        return info
    }

    cast := skip_to_type(curr_node.children, "cast")
    if cast != null {
        cast_type := skip_to_type(cast.children, "type")

        type := node_to_type(ctx, cast_type.children)
        -- chr* new_id
        -- io.asprintf(&new_id, "%%.tmp%d", new_uid(ctx))
        prev_id := repr_assignable_id(info)
        set_assignable_tmp_id(ctx, info)

        from_type := type_repr(ctx, info.type)
        to_type := type_repr(ctx, type)

        cast_fn := "bitcast"

        if string.strcmp(info.type.container, "ptr") != 0 & string.strcmp(type.container, "ptr") != 0 {
            if from_type[0] == 'i' & to_type[0] == 'i' {
                int from_size
                int to_size
                io.sscanf(from_type, "i%d", &from_size)
                io.sscanf(to_type, "i%d", &to_size)

                if from_size < to_size {
                    cast_fn = "sext"
                } else {
                    cast_fn = "trunc"
                }
            }
        }

        io.fprintf(ctx.ir, "%s = %s %s %s to %s\n", repr_assignable_id(info), cast_fn, from_type, prev_id, to_type)

        info.type = type
    }
    return info
}

AssignableInfo* compile_assignable_stack(CompilerCtx* ctx, StackHead* stack) {
    if string.strcmp(stack.h.n.type, "mono_assignable") == 0 {
        return compile_mono_assignable(ctx, stack.h.n)
    }
    operator := stack.h.n.children

    stack.h = stack.h.prev
    A := compile_assignable_stack(ctx, stack)

    if A == null {
        return A
    }

    stack.h = stack.h.prev
    B := compile_assignable_stack(ctx, stack)
    if B == null {
        return B
    }

    op_info := new_assignable_info((parser.Node*) null)
    op_info.type = operator_type(operator)

    -- op_id := new_uid(ctx)
    set_assignable_tmp_id(ctx, op_info)
    io.fprintf(ctx.ir, "%s = %s %s %s, %s\n", repr_assignable_id(op_info), operator_op(ctx, operator), type_repr(ctx, A.type), repr_assignable_id(A), repr_assignable_id(B))

    return op_info
}

str operator_op(CompilerCtx* ctx, parser.Node* op) {
    if op == null {
        io.printf(err_tmpl(ctx, op, "called 'operator_op' with null"))
    }

    if string.strcmp(op.value, "+") == 0 {
        return "add"
    } elif string.strcmp(op.value, "-") == 0 {
        return "sub"
    } elif string.strcmp(op.value, "*") == 0 {
        return "mul"
    } elif string.strcmp(op.value, "/") == 0 {
        return "sdiv"
    } elif string.strcmp(op.value, "==") == 0 {
        return "icmp eq"
    } elif string.strcmp(op.value, "!=") == 0 {
        return "icmp ne"
    } elif string.strcmp(op.value, ">") == 0 {
        return "icmp sgt"
    } elif string.strcmp(op.value, "<") == 0 {
        return "icmp slt"
    } elif string.strcmp(op.value, "&") == 0 {
        return "and"
    } elif string.strcmp(op.value, "|") == 0 {
        return "or"
    } elif string.strcmp(op.value, ">=") == 0 {
        return "icmp sge"
    } elif string.strcmp(op.value, "<=") == 0 {
        return "icmp sle"
    } else {
        io.printf(err_tmpl(ctx, op, "operator '%s' not implemented"), op.value)
    }
    return "add"
}

Type* operator_type(parser.Node* op) {
    type := new_type()
    if string.strcmp(op.value, "==") == 0 | string.strcmp(op.value, "!=") == 0 | string.strcmp(op.value, "|") == 0 | string.strcmp(op.value, "&") == 0 | string.strcmp(op.value, ">") == 0 | string.strcmp(op.value, "<") == 0 | string.strcmp(op.value, ">=") == 0 | string.strcmp(op.value, "<=") == 0 {
        type.container = "bool"
    } else {
        type.container = "int"
    }
    return type
}

AssignableInfo* compile_mono_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    AssignableInfo* assignable_info = (AssignableInfo*) null
    mono := curr_node
    chr* err_buf
    chr* buf

    if string.strcmp(mono.children.type, "NUMBER") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = new_type()
        assignable_info.type.container = "int"
        set_assignable_id(assignable_info, SCOPE_CONST, mono.children.value)

    } elif string.strcmp(mono.children.type, "WORD") == 0 {
        if string.strcmp(mono.children.value, "null") != 0 {
            io.printf(err_tmpl(ctx, curr_node, "unable to interpret %s as mono_assignable"), mono.children.value)
            return (AssignableInfo*) null
        }
        assignable_info = new_assignable_info(curr_node)
        set_assignable_id(assignable_info, SCOPE_CONST, "null")
        assignable_info.type = new_type()
        assignable_info.type.container = "nullptr"

    } elif string.strcmp(mono.children.type, "addr_destination") == 0 {
        assignable_info = new_assignable_info(curr_node)
        dest := skip_to_type(mono.children.children, "destination")
        var_info := compile_addr(ctx, dest)

        if var_info == null {
            return assignable_info
        }

        var_type_repr := type_repr(ctx, var_info.type)
        set_assignable_tmp_id(ctx, assignable_info)

        assignable_info.type = var_info.type
        for ptr := mono.children.children; ptr != dest; ptr = ptr.next {
            type := new_type()
            type.of = assignable_info.type
            type.container = "ptr"

            assignable_info.type = type
        }

        if mono.children.children != dest {
            -- it's a pointer, load it's address
            io.fprintf(ctx.ir, "%s = getelementptr %s, %s* %s, i32 0\n", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        } else {
            -- it's a variable, load it's content
            io.fprintf(ctx.ir, "%s = load %s, %s* %s\n", repr_assignable_id(assignable_info), var_type_repr, var_type_repr, repr_assignable_id(var_info))
        }

    } elif string.strcmp(mono.children.type, "boolean") == 0 {
        assignable_info = new_assignable_info(curr_node)
        assignable_info.type = new_type()
        assignable_info.type.container = "bool"
        if string.strcmp(mono.children.children.value, "false") == 0 {
            set_assignable_id(assignable_info, SCOPE_CONST, "0")
        } else {
            set_assignable_id(assignable_info, SCOPE_CONST, "1")
        }
    } elif string.strcmp(mono.children.type, "fn_call") == 0 {
        assignable_info = compile_fn_call(ctx, mono.children.children)
    } elif string.strcmp(mono.children.type, "STRING") == 0 {
        string_info := define_string(ctx, mono.children.value) -- defines strings for future reuse, plus defines global functions or data structures when used
        assignable_info = new_assignable_info(curr_node)
        set_assignable_tmp_id(ctx, assignable_info)

        str_tr := type_repr(ctx, string_info.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s*%s, i32 0, i32 0\n", repr_assignable_id(assignable_info), str_tr, str_tr, repr_assignable_id(string_info))

        assignable_info.type = new_type()
        assignable_info.type.container = "ptr"
        assignable_info.type.of = new_type()
        assignable_info.type.of.container = "chr"

    } elif string.strcmp(mono.children.type, "CHR") == 0 {
        assignable_info = new_assignable_info(curr_node)
        chr_len := string.strlen(mono.children.value)
        set_assignable_id(assignable_info, SCOPE_CONST, "0")

        assignable_info.id = llvm.chr_to_llvm(mono.children.value)
        if assignable_info.id == null {
            io.asprintf(&err_buf, "Invalid character: %s", mono.children.value)
            return (AssignableInfo*) null
        }
        assignable_info.type = new_type()
        assignable_info.type.container = "chr"
    } else {
        io.printf(err_tmpl(ctx, mono, "unable to compile assignable of type %s"), mono.children.type)
        return (AssignableInfo*) null
    }

    if assignable_info == null {
        return (AssignableInfo*) null
    }
    assignable_info.line = curr_node.line
    assignable_info.char_of_line = curr_node.char_of_line
    return (AssignableInfo*) assignable_info
}

str type_abbr(Type* type) {
    sys.assert(type != null, "called 'abbr' on null")
    sys.assert(type.container != null, "called 'type_abbr' with malformed type, container is null.")
    if string.strcmp(type.container, "int") == 0 {
        return "i"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "b"
    } elif string.strcmp(type.container, "void") == 0 {
        return "v"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "c"
    } elif string.strcmp(type.container, "ptr") == 0 {
        chr* buf
        io.asprintf(&buf, "%sp", type_abbr(type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        return type.repr
    } elif string.strcmp(type.container, "error") == 0 {
        return "?"
    } else {
        io.printf(":coffee-error: unable to abbreviate type %s", type.container)
    }
    return (chr*) null
}

AssignableInfo* define_string(CompilerCtx* ctx, str text) {
    info := new_assignable_info((parser.Node*) null)
    chr* tmp_buff
    io.asprintf(&tmp_buff, ".str%d", new_uid(ctx))
    set_assignable_id(info, SCOPE_GLOBAL, tmp_buff)

    global := (GlobalName*) sys.malloc(sizeof(GlobalName))
    global.identifier = llvm.string_to_llvm(text)

    info.type = new_type()
    info.type.container = "array"
    info.type.of = new_type()
    info.type.of.container = "chr"
    info.type.of.next = new_type()

    io.asprintf(&info.type.of.next.container, "%d", llvm.llvm_str_len(global.identifier))

    global.global_type = "string"
    global.next = null
    global.info = info
    global.compiled = false
    append_global(ctx, global)
    return info
}

void define_module(CompilerCtx* ctx, parser.Node* mod, str as_name, abspath) {
    info := new_assignable_info(mod)
    set_assignable_id(info, SCOPE_CONST, abspath)
    info.name_type = "module"
    info.type = null

    define_assignable(ctx, as_name, info)
}

void append_global(CompilerCtx* ctx, GlobalName* g) {
    if ctx.globals == null {
        ctx.globals = g
    } else {
        GlobalName* last_global
        for last_global = ctx.globals; last_global.next != null; last_global = last_global.next {
        }
        last_global.next = g
    }
}

str type_repr(CompilerCtx* ctx, Type* type) {
    if type == null {
        if DEBUG_INTERNALS {
            io.printf(":panic: %s called 'type_repr' on null type\n", ctx.current_module)
        }
        return "?"
    }
    sys.assert(type.container != null, "called 'type_repr' with malformed type, container is null.")
    chr* buf

    if string.strcmp(type.container, "int") == 0 {
        return "i32"
    } elif string.strcmp(type.container, "void") == 0 {
        return "void"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "i1"
    } elif string.strcmp(type.container, "nullptr") == 0 {
        return "ptr"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "i8"
    } elif string.strcmp(type.container, "function") == 0 {
        io.asprintf(&buf, "%s(", type_repr(ctx, type.of))
        for p := type.of.next; p != null; p = p.next {
            if p != type.of.next {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(ctx, p))
        }
        io.asprintf(&buf, "%s)", buf)
        return buf
    } elif string.strcmp(type.container, "ptr") == 0 {
        io.asprintf(&buf, "%s*", type_repr(ctx, type.of))
        return buf
    } elif string.strcmp(type.container, "struct") == 0 {
        -- io.asprintf(&buf, "{%s}", type_repr(type.of)
        io.asprintf(&buf, "{")
        for t := type.of; t != null; t = t.next {
            if t != type.of {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(ctx, t))
        }
        io.asprintf(&buf, "%s}", buf)
        return buf
    } elif string.strcmp(type.container, "array") == 0 {
        io.asprintf(&buf, "[%s x %s]", type.of.next.container, type_repr(ctx, type.of))
        return buf
    } elif string.strcmp(type.container, "typealias") == 0 {
        io.asprintf(&buf, "%%%s", type.repr)
        return buf
    } elif string.strcmp(type.container, "vararg") == 0 {
        return "..."
    } elif string.strcmp(type.container, "error") == 0 {
        -- syntax error occurred before, not returning anything as type container
    } else {
        io.printf(":coffee-error: 'type_repr' not implemented for type '%s'\n", type.container)
    }

    return (chr*) null
}

void append_error(CompilerCtx* ctx, errors.Error* e) {
    new_err := (ErrorList*) sys.malloc(sizeof(ErrorList))
    new_err.err = e
    new_err.next = null

    if ctx.errors == null {
        ctx.errors = new_err
        return
    }

    for last := ctx.errors; last.next != null ; last = last.next {
    }

    last.next = new_err
}

chr* syn_function_name(parser.Node* stmt) {
    return stmt.children.next.value
}
parser.Node* skip_to_type(parser.Node* node, str type) {
    for n := node; n != null; n = n.next {
        if string.strcmp(n.type, type) == 0 {
            return n
        }
    }
    return (parser.Node*) null
}


Type* syn_function_type(CompilerCtx* ctx, parser.Node* stmt) {
    function_type := new_type()

    return_value_type := node_to_type(ctx, stmt.children)
    function_type.container = "function"
    function_type.of = return_value_type

    last_type := return_value_type
    params := syn_function_params(stmt)

    for param_ptr := params; param_ptr != null ; {
        if string.strcmp(param_ptr.type, "WORD") == 0 {
            last_type.next = type_clone(last_type)
            last_type.next.next = null
            last_type = last_type.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next
            }
            if param_ptr.next != null {
                param_ptr = param_ptr.next
            } else {
                param_ptr = null
            }
        } else {
            param_type := node_to_type(ctx, param_ptr.children)
            last_type.next = param_type
            last_type = param_type
            param_ptr = param_ptr.next

            if param_ptr.next != null {
                param_ptr = param_ptr.next.next
            } else {
                param_ptr = null
            }
        }
    }

    -- start parsing argument types
    return function_type
}

parser.Node* syn_function_params(parser.Node* stmt) {
    params := skip_to_type(stmt, "fn_params")
    if params == null {
        return (parser.Node*) null
    }
    return params.children
}

Type* node_to_type(CompilerCtx* ctx, parser.Node* stmt) {
    t := new_type()

    if string.strcmp(stmt.type, "structdef") == 0 {
        t.container = "struct"
        t.info = null

        curr_type := skip_to_type(stmt.children, "type")
        if curr_type != null {
            t.of = node_to_type(ctx, curr_type.children)
            t.of.info = curr_type.next.value

            curr_t := t.of
            for curr_type = skip_to_type(curr_type.next, "type"); curr_type != null; curr_type = skip_to_type(curr_type.next, "type") {
                curr_t.next = node_to_type(ctx, curr_type.children)
                curr_t.next.info = curr_type.next.value
                curr_t = curr_t.next
            }
        }
        -- parse struct fields
    } elif string.strcmp(stmt.type, "dotted_name") == 0 {
        -- 1st resolve dotted name
        -- 2nd create type
        chr* err_msg
        base := find_defined(ctx, stmt)
        if base == null {
            io.asprintf(&err_msg, "Name %s is not defined in this scope", stmt.children.value)
            new_error(ctx, stmt, err_msg)
            t.container = "error"
            return t
        }

        t.container = "typealias"

        t.info = base.name
        t.repr = base.info.id

        t.of = base.info.type
    } elif string.strcmp(stmt.value, "str") == 0 {
        t.container = "ptr"
        t.of = new_type()
        t.of.container = "chr"
    } elif string.strcmp(stmt.type, "WORD") == 0 {
        t.container = stmt.value

    } elif string.strcmp(stmt.value, "...") == 0 {
        t.container = "vararg"
    } else {
        io.printf(err_tmpl(ctx, stmt, "unable to convert statement of type '%s' to type (%s)"), stmt.type, stmt.value)
    }

    for ptr := stmt.next; ptr != null; ptr = ptr.next {
        pt := new_type()
        pt.container = "ptr"
        pt.of = t
        t = pt
    }

    return t
}

