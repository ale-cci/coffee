import "../std/sys" as sys
import "../std/io" as io
import "../parser" as parser
import "../std/string" as string

import "../parser.debug" as parser_debug
import "../errors" as errors

alias ErrorList = struct {
    errors.Error* err,
    ErrorList* next,
}
int ErrorList_size = 16

alias Type = struct {
    chr* container,

    -- NOTE: each "basic" type is not allowed to have a 'next'
    -- value

    Type* of,
    Type* next,

    -- Type* of,
    -- chr* container,
}
int Type_size = 24

alias AssignableInfo = struct {
    -- uniquely identifies assignable
    chr* id,
    chr* name_type,
    Type* type,

    -- where was the assignable defined
    int line,
    int char_of_line,
}
int AssignableInfo_size = 32

alias ScopeItem = struct {
    chr* name,
    AssignableInfo* info,
    ScopeItem* next,
}
int ScopeItem_size = 24

alias GlobalName = struct {
    chr* identifier,

    chr* global_type, -- string, function
    AssignableInfo* info,
    GlobalName* next,
}
int GlobalName_size = 32

alias Scope = struct {
    ScopeItem* item,
    Scope* prev,
}
int Scope_size = 16

alias CompilerCtx = struct {
    parser.Node* root,
    io.File* ir,
    ErrorList* errors,
    Scope *scopes,
    GlobalName* globals,
    int counter,
}
int CompilerCtx_size = 52

int new_uid(CompilerCtx* ctx) {
    uid := ctx.counter
    ctx.counter = ctx.counter + 1
    return uid
}



CompilerCtx* new_context(io.File* fd) {
    CompilerCtx* ctx = (CompilerCtx*) sys.malloc(CompilerCtx_size)
    ctx.ir = fd
    ctx.root = (parser.Node*) null
    ctx.errors = null
    ctx.counter = 0
    ctx.scopes = null
    ctx.globals = null

    return (CompilerCtx*) ctx
}

void push_scope(CompilerCtx* ctx) {
    s := (Scope*) sys.malloc(Scope_size)
    s.prev = ctx.scopes
    s.item = null
    ctx.scopes = s
}
void pop_scope(CompilerCtx* ctx) {
    -- TODO: free this scope -> s := ctx.scopes
    sys.assert(ctx.scopes != null, ":coffee-error: 'pop_scope' called when ctx.scopes is null")
    ctx.scopes = ctx.scopes.prev
}

bool compile(CompilerCtx* ctx, parser.Node* ast) {
    if string.strcmp(ast.type, "start") != 0 {
        return false
    }

    -- push global context scope
    push_scope(ctx)

    for s := ast.children; s != null; s = s.next {
        compile_statement(ctx, s.children)
    }

    has_errors := ctx.errors != null
    for err := ctx.errors; err != null; err = err.next {
        errors.report(err.err)
    }
    pop_scope(ctx)


    -- add globals
    for g := ctx.globals; g != null; g = g.next {
        compile_global(ctx, g)
    }

    -- TODO: free errors
    return has_errors
}

str string_to_llvm(chr* text) {
    chr* buf
    str_len := string.strlen(text)
    chr* substr = sys.malloc(str_len)
    for i := 0; i < str_len -2; i = i + 1 {
        substr[i] = text[i + 1]
    }
    substr[str_len -2] = '\00'
    io.asprintf(&buf, "c\22%s\5C00\22", substr)
    sys.free(substr)

    return buf
}

void compile_global(CompilerCtx* ctx, GlobalName* g) {
    if string.strcmp(g.global_type, "string") == 0 {
        repr := string_to_llvm(g.identifier)
        io.fprintf(ctx.ir, "%s = constant %s %s\0A", g.info.id, type_repr(g.info.type), repr)
    }
}

str name_mangle(str original_name, str filename, Type* type) {
    chr* mangled_name

    io.asprintf(&mangled_name, "@%s", original_name)
    if string.strcmp(type.container, "function") == 0 {
        -- function  name is the concatenation of module, original name
        -- return value and parameters type
        if string.strcmp(original_name, "main") != 0 {
            chr* tmp_buff
            chr* swap_var
            for tp := type.of; tp != null; tp = tp.next {
                io.asprintf(&tmp_buff, "%s.%s", mangled_name, type_abbr(tp))

                swap_var = tmp_buff
                tmp_buff = mangled_name
                mangled_name = swap_var
                sys.free(tmp_buff)
            }
        }
    }

    return mangled_name
}

void compile_statement(CompilerCtx* ctx, parser.Node* stmt) {
    AssignableInfo* info
    Type* return_type

    if string.strcmp(stmt.type, "NL") == 0 {
        return
    } elif string.strcmp(stmt.type, "global") == 0 {
        assignable := skip_to_type(stmt.children, "assignable")
        a_info := compile_assignable(ctx, assignable)

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&info.id, "@%s", stmt.children.next.value)
        info.type = a_info.type

        io.fprintf(ctx.ir, "%s = constant %s %s\0A", info.id, type_repr(info.type), a_info.id)
    } elif string.strcmp(stmt.type, "extern") == 0 {
        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.type = syn_function_type(stmt.children.next)
        info.name_type = "extern"
        io.asprintf(&info.id, "@%s", stmt.children.next.next.value)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.next = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "declare %s %s(", type_repr(return_type), info.id)
        for pt := info.type.of.next; pt != null; pt = pt.next {
            if pt != info.type.of.next {
                io.fprintf(ctx.ir, ", ")
            }
            io.fprintf(ctx.ir, "%s", type_repr(pt))
        }

        io.fprintf(ctx.ir, ")\0A")
        sys.free((chr*) return_type)

    } elif string.strcmp(stmt.type, "function") == 0 {
        -- function definition
        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.name_type = "function"
        info.type = syn_function_type(stmt.children)

        name := syn_function_name(stmt)
        info.id = name_mangle(name, "", info.type)
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line
        define_assignable(ctx, name, info)

        -- copy defined function return type
        return_type = (Type*) sys.malloc(Type_size)
        return_type.next = null
        return_type.container = info.type.of.container
        return_type.of = info.type.of.of

        io.fprintf(ctx.ir, "define %s %s(", type_repr(return_type), info.id)
        params := syn_function_params(stmt.children)
        for param_ptr := params; param_ptr != null ; {
            if param_ptr != params {
                param_ptr = param_ptr.next
                io.fprintf(ctx.ir, ", ")
            }
            param_type := node_to_type(param_ptr.children)
            io.fprintf(ctx.ir, "%s %%.%s.arg", type_repr(param_type), param_ptr.next.value)
            param_ptr = param_ptr.next.next
        }
        -- build function parameters string
        io.fprintf(ctx.ir, ") {\0A")
        compile_fn_params(ctx, params)

        fn_block := skip_to_type(stmt.children, "block")
        compile_block(ctx, fn_block)


        parser.Node* last_valid_instruction = (parser.Node*) null

        -- check if last instruction is a return stmt
        -- otherwise add implicit void return
        -- or signal an error
        for ci := fn_block.children; ci.next != null; ci = ci.next {
            if string.strcmp(ci.type, "NL") != 0 & string.strcmp(ci.type, "OPERATOR") != 0 {
                last_valid_instruction = ci
            }
        }

        add_implicit_return := false
        if last_valid_instruction == null {
            add_implicit_return = true
        } elif string.strcmp(last_valid_instruction.children.type, "return") != 0 {
            add_implicit_return = true
        }

        if add_implicit_return {
            if string.strcmp(type_repr(return_type), "void") != 0 {
                new_error(ctx, fn_block, "missing return value")
            } else {
                io.fprintf(ctx.ir, "ret void\0A")
            }
        }

        io.fprintf(ctx.ir, "}\0A")

    } else {

        chr* err_buf
        io.asprintf(&err_buf, "Unable to convert statement of type %s to ast", stmt.type)
        new_error(ctx, stmt, err_buf)
    }
}

void compile_fn_params(CompilerCtx* ctx, parser.Node* fn_params) {
    for param_ptr := fn_params; param_ptr != null ; {
        if param_ptr != fn_params {
            param_ptr = param_ptr.next
        }

        var_name := param_ptr.next.value

        param_info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&param_info.id, "%%%s", var_name)
        param_info.name_type = "variable"
        param_info.type = node_to_type(param_ptr.children)
        param_info.line = param_ptr.line
        param_info.char_of_line = param_ptr.char_of_line

        param_info_tr := type_repr(param_info.type)
        io.fprintf(ctx.ir, "%s = alloca %s\0A", param_info.id, param_info_tr)
        define_assignable(ctx, var_name, param_info)
        io.fprintf(ctx.ir, "store %s %%.%s.arg, %s* %s\0A", param_info_tr, var_name, param_info_tr, param_info.id)
        param_ptr = param_ptr.next.next
    }
}


void compile_block(CompilerCtx* ctx, parser.Node* stmt) {
    push_scope(ctx)
    -- parse only expressions
    for b := stmt.children; b != null ; b = b.next {
        if string.strcmp(b.type, "expression") == 0 {
            compile_expression(ctx, b.children)
        }
    }
    pop_scope(ctx)
}

AssignableInfo* compile_fn_call(CompilerCtx* ctx, parser.Node* stmt) {
    info := compile_addr(ctx, stmt)
    args := skip_to_type(stmt, "fn_args")
    chr* params_buff = ""
    chr* tmp
    if args != null {
        start := skip_to_type(args.children, "assignable")
        for pp := start; pp != null; pp = skip_to_type(pp, "assignable") {
            if pp != start {
                io.asprintf(&tmp, "%s, ", params_buff)
                chr* tmp_buff = params_buff
                params_buff = tmp
                tmp = tmp_buff
                sys.free(tmp)
            }
            a_info := compile_assignable(ctx, pp)
            io.asprintf(&params_buff, "%s%s %s", params_buff, type_repr(a_info.type), a_info.id)
            pp = pp.next
        }
    }

    chr* uid = ""
    if string.strcmp(type_repr(info.type.of), "void") != 0 {
        io.asprintf(&uid, "%%.tmp%d", new_uid(ctx))
    }

    if string.strcmp(uid, "") == 0 {
        io.fprintf(ctx.ir, "call %s %s(%s)\0A", type_repr(info.type), info.id, params_buff)
        return (AssignableInfo*) null

    } else {
        io.fprintf(ctx.ir, "%s = call %s %s(%s)\0A", uid, type_repr(info.type), info.id, params_buff)
    }
    -- get function arguments

    AssignableInfo* call_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
    call_info.type = info.type.of
    call_info.type.next = null
    call_info.id = uid

    return (AssignableInfo*) call_info
}

void compile_expression(CompilerCtx* ctx, parser.Node* stmt) {
    chr* err_msg
    expr_type := stmt.type

    AssignableInfo* info = (AssignableInfo*) null
    parser.Node* assignable
    AssignableInfo* a_info = (AssignableInfo*) null

    if string.strcmp(expr_type, "return") == 0 {
        if string.strcmp(stmt.children.next.type, "NL") != 0 {
            info = compile_assignable(ctx, stmt.children.next)
            io.fprintf(ctx.ir, "ret %s %s\0A", type_repr(info.type), info.id)
        } else {
            io.fprintf(ctx.ir, "ret void\0A")
        }

    } elif string.strcmp(expr_type, "NL") == 0 {
    } elif string.strcmp(expr_type, "fn_call") == 0 {
        -- get function name from destination
        compile_fn_call(ctx, stmt.children)
        -- get function arguments
    } elif string.strcmp(expr_type, "declaration") == 0 {
        Type* decl_type = (Type*) null
        if string.strcmp(stmt.children.type, "type") == 0 {
            decl_type = node_to_type(stmt.children.children)
        }

        assignable = skip_to_type(stmt.children, "assignable")
        if assignable != null {
            a_info = compile_assignable(ctx, assignable)
        }

        info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        info.name_type = "variable"
        info.line = stmt.line
        info.char_of_line = stmt.char_of_line
        var_name := skip_to_type(stmt.children, "WORD")

        sys.assert(var_name != null, ":coffee-error: unalbe to get declaration name")

        io.asprintf(&info.id, "%%%s", var_name.value)
        if decl_type != null {
            info.type = decl_type
        } elif a_info != null {
            info.type = a_info.type
        }

        var_type_repr := type_repr(info.type)
        if a_info != null {
            a_type_repr := type_repr(a_info.type)
            type_error := false
            if string.strlen(a_type_repr) != string.strlen(var_type_repr) {
                type_error = true
            } elif string.strcmp(a_type_repr, var_type_repr) != 0 {
                type_error = true
            }

            if type_error {
                io.asprintf(&err_msg, "cannot assign type '%s' to variable of type '%s'", a_type_repr, var_type_repr)
                new_error(ctx, stmt, err_msg)
            }
        }
        define_assignable(ctx, var_name.value, info)

        io.fprintf(ctx.ir, "%s = alloca %s\0A", info.id, var_type_repr)
        if a_info != null {
            io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), a_info.id, var_type_repr, info.id)
        }

    } elif string.strcmp(expr_type, "assignment") == 0 {
        assignable = skip_to_type(stmt.children, "assignable")
        dest := compile_addr(ctx, stmt.children)
        if dest == null {
            io.asprintf(&err_msg, "%s was not declared in this scope", stmt.children.children.children.value)
            new_error(ctx, stmt, err_msg)
            return
        }
        a_info = compile_assignable(ctx, assignable)

        io.fprintf(ctx.ir, "store %s %s, %s* %s\0A", type_repr(a_info.type), a_info.id, type_repr(dest.type), dest.id)
    } elif string.strcmp(expr_type, "if_block") == 0 {
        if_id := new_uid(ctx)

        assignable = skip_to_type(stmt.children, "assignable")
        a_info = compile_assignable(ctx, assignable)

        io.fprintf(ctx.ir, "br %s %s, label %%.if.true.%d, label %%.if.false.%d\0A", type_repr(a_info.type), a_info.id, if_id, if_id)
        io.fprintf(ctx.ir, ".if.true.%d:\0A", if_id)
        io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
        io.fprintf(ctx.ir, ".if.false.%d:\0A", if_id)
        io.fprintf(ctx.ir, "br label %%.if.end.%d\0A", if_id)
        io.fprintf(ctx.ir, ".if.end.%d:\0A", if_id)
    } else {
        io.printf("compiling expression: %s\0A", expr_type)
    }
}


void new_error(CompilerCtx* c, parser.Node* curr_node, str msg) {
    if curr_node != null {
        err := errors.new(curr_node.filename, curr_node.line, curr_node.char_of_line, msg)
        append_error(c, err)
    } else {
        sys.assert(false, "Programming error, unable to create new error from null node")
    }
}

-- binds the assignable to a given name in the current scope
void define_assignable(CompilerCtx* ctx, str name, AssignableInfo* info) {
    sys.assert(ctx.scopes != null, ":coffee-error: 'define_assignable' could not be called if context scopes are null")
    current_scope := ctx.scopes

    -- check that assignable is not defined on this context
    -- for item := current_scope.item; item != null; item = item.next {
    -- }

    newitem := (ScopeItem*) sys.malloc(ScopeItem_size)
    newitem.name = name
    newitem.info = info
    newitem.next = null

    if current_scope.item == null {
        current_scope.item = newitem
        return
    }

    for last_item := current_scope.item; last_item.next != null; last_item = last_item.next {
    }
    last_item.next = newitem
}

AssignableInfo* find_defined(CompilerCtx* ctx, parser.Node* dotted_name) {
    sys.assert(ctx.scopes != null, ":coffee-error: 'find_defined' could not be called if context scopes are null")

    assignable_name := dotted_name.children.value
    for s := ctx.scopes; s != null; s = s.prev {
        for item := s.item; item != null; item = item.next {
            if string.strcmp(item.name, assignable_name) == 0 {
                return item.info
            }
        }
    }
    return (AssignableInfo*) null
}

-- returns address for node
AssignableInfo* compile_addr(CompilerCtx* c, parser.Node* curr_node) {
    if string.strcmp(curr_node.type, "destination") != 0 {
        io.printf("'compile_addr' could only be called on destinations for now. (called on %s)\0A", curr_node.type)
        return (AssignableInfo*) null
    }

    -- type + id of addr
    assignable_name := curr_node.children
    info := find_defined(c, assignable_name)
    if info == null {
        return (AssignableInfo*) null
    }

    if string.strcmp(info.name_type, "function") == 0 {
        return info
    } elif string.strcmp(info.name_type, "variable") == 0 {
        return info
    }

    -- info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
    -- io.asprintf(&info.id, "@%s", fn_name)

    -- build type


    -- type


    -- io.printf("Retrieving addr of: %s\0A", curr_node.type)
    -- io.printf("function called: %s\0A", curr_node.children.children.value)
    return (AssignableInfo*) null
}


AssignableInfo* compile_assignable(CompilerCtx* ctx, parser.Node* curr_node) {
    AssignableInfo* assignable_info = (AssignableInfo*) null
    mono := skip_to_type(curr_node.children, "mono_assignable")

    if string.strcmp(mono.children.type, "NUMBER") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.of = null
        assignable_info.type.container = "int"
        assignable_info.id = mono.children.value
    } elif string.strcmp(mono.children.type, "addr_destination") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        dest := skip_to_type(mono.children.children, "destination")

        var_info := find_defined(ctx, dest.children)
        var_type_repr := type_repr(var_info.type)

        io.asprintf(&assignable_info.id, "%%.tmp%d", new_uid(ctx))
        assignable_info.type = var_info.type

        io.fprintf(ctx.ir, "%s = load %s, %s* %s\0A", assignable_info.id, var_type_repr, var_type_repr, var_info.id)

    } elif string.strcmp(mono.children.type, "boolean") == 0 {
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.of = null
        assignable_info.type.container = "bool"
        if string.strcmp(mono.children.children.value, "false") == 0 {
            assignable_info.id = "0"
        } else {
            assignable_info.id = "1"
        }
    } elif string.strcmp(mono.children.type, "fn_call") == 0 {
        assignable_info = compile_fn_call(ctx, mono.children.children)
    } elif string.strcmp(mono.children.type, "STRING") == 0 {
        string_info := define_string(ctx, mono.children.value) -- defines strings for future reuse, plus defines global functions or data structures when used
        assignable_info = (AssignableInfo*) sys.malloc(AssignableInfo_size)
        io.asprintf(&assignable_info.id, "%%.tmp%d", new_uid(ctx))

        str_tr := type_repr(string_info.type)
        io.fprintf(ctx.ir, "%s = getelementptr %s, %s*%s, i32 0, i32 0\0A", assignable_info.id, str_tr, str_tr, string_info.id)

        assignable_info.type = (Type*) sys.malloc(Type_size)
        assignable_info.type.container = "ptr"
        assignable_info.type.of = (Type*) sys.malloc(Type_size)
        assignable_info.type.of.container = "chr"
        assignable_info.type.of.of = null
    } else {
        io.printf(":coffee-error: unable to compile assignable of type %s\0A", mono.children.type)
        return (AssignableInfo*) null
    }

    assignable_info.line = curr_node.line
    assignable_info.char_of_line = curr_node.char_of_line
    return (AssignableInfo*) assignable_info
}

str type_abbr(Type* type) {
    sys.assert(type != null, "called 'abbr' on null")
    sys.assert(type.container != null, "called 'type_abbr' with malformed type, container is null.")
    if string.strcmp(type.container, "int") == 0 {
        return "i"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "b"
    } elif string.strcmp(type.container, "void") == 0 {
        return "v"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "c"
    }
    return (chr*) null
}

AssignableInfo* define_string(CompilerCtx* ctx, str text) {
    info := (AssignableInfo*) sys.malloc(AssignableInfo_size)
    io.asprintf(&info.id, "@.str%d", new_uid(ctx))
    info.type = (Type*) sys.malloc(Type_size)
    info.type.container = "array"
    info.type.of = (Type*) sys.malloc(Type_size)
    info.type.of.container = "chr"
    info.type.of.of = null
    info.type.of.next = (Type*) sys.malloc(Type_size)
    info.type.of.next.of = null
    io.asprintf(&info.type.of.next.container, "%d", string.strlen(text) -2 +1)

    global := (GlobalName*) sys.malloc(GlobalName_size)
    global.identifier = text
    global.global_type = "string"
    global.next = null
    global.info = info
    append_global(ctx, global)
    return info
}

void append_global(CompilerCtx* ctx, GlobalName* g) {
    if ctx.globals == null {
        ctx.globals = g
    } else {
        GlobalName* last_global
        for last_global = ctx.globals; last_global.next != null; last_global = last_global.next {
        }
        last_global.next = g
    }
}

str type_repr(Type* type) {
    sys.assert(type != null, "called 'type_repr' on null")
    sys.assert(type.container != null, "called 'type_repr' with malformed type, container is null.")
    chr* buf

    if string.strcmp(type.container, "int") == 0 {
        return "i32"
    } elif string.strcmp(type.container, "void") == 0 {
        return "void"
    } elif string.strcmp(type.container, "bool") == 0 {
        return "i1"
    } elif string.strcmp(type.container, "chr") == 0 {
        return "i8"
    } elif string.strcmp(type.container, "function") == 0 {
        io.asprintf(&buf, "%s(", type_repr(type.of))
        for p := type.of.next; p != null; p = p.next {
            if p != type.of.next {
                io.asprintf(&buf, "%s,", buf)
            }
            io.asprintf(&buf, "%s%s", buf, type_repr(p))
        }
        io.asprintf(&buf, "%s)", buf)
        return buf
    } elif string.strcmp(type.container, "ptr") == 0 {
        io.asprintf(&buf, "%s*", type_repr(type.of))
        return buf
    } elif string.strcmp(type.container, "array") == 0 {
        io.asprintf(&buf, "[%s x %s]", type.of.next.container, type_repr(type.of))
        return buf
    } else {
        io.printf(":coffee-error: 'type_repr' not implemented for type %s\0A", type.container)
    }

    return (chr*) null
}

void append_error(CompilerCtx* ctx, errors.Error* e) {
    new_err := (ErrorList*) sys.malloc(ErrorList_size)
    new_err.err = e
    new_err.next = null

    if ctx.errors == null {
        ctx.errors = new_err
        return
    }

    for last := ctx.errors; last.next != null ; last = last.next {
    }

    last.next = new_err
}

chr* syn_function_name(parser.Node* stmt) {
    return stmt.children.next.value
}
parser.Node* skip_to_type(parser.Node* node, str type) {
    for n := node; n != null; n = n.next {
        if string.strcmp(n.type, type) == 0 {
            return n
        }
    }
    return (parser.Node*) null
}


Type* syn_function_type(parser.Node* stmt) {
    function_type := (Type*) sys.malloc(Type_size)

    return_value_type := node_to_type(stmt.children)
    function_type.container = "function"
    function_type.of = return_value_type

    last_type := return_value_type
    params := syn_function_params(stmt)

    for param_ptr := params; param_ptr != null ; param_ptr = skip_to_type(param_ptr, "type") {
        param_type := node_to_type(param_ptr.children)
        last_type.next = param_type
        last_type = param_type
        param_ptr = param_ptr.next
    }

    -- start parsing argument types
    return function_type
}

parser.Node* syn_function_params(parser.Node* stmt) {
    params := skip_to_type(stmt, "fn_params")
    if params == null {
        return (parser.Node*) null
    }
    return params.children
}

Type* node_to_type(parser.Node* stmt) {
    t := (Type*) sys.malloc(Type_size)
    t.of = null
    t.next = null
    t.container = stmt.value
    return t
}
