import "./std/io" as io
import "./std/sys" as sys
import "./std/testing" as testing
import "./parser" as parser


int main() {
    t := testing.init("parser.test.bn")

    testing.setup(t, "parses one word matcher")
    testing.run(t, should_parse_one_word_matcher(t))

    testing.setup(t, "parses multiple words matcher")
    testing.run(t, should_parse_two_consecutive_tokens(t))

    testing.setup(t, "parses repeating condition +")
    testing.run(t, should_parse_repeating_condition_plus(t))

    testing.setup(t, "parses repeating condition *")
    testing.run(t, should_parse_repeating_condition_times(t))

    testing.setup(t, "should parse or condition")
    testing.run(t, should_parse_or_condition(t))

    testing.setup(t, "parses repeating condition ?")
    testing.run(t, should_parse_repeating_condition_question(t))

    testing.setup(t, "parses rule")
    testing.run(t, should_parse_matching_rule(t))

    testing.setup(t, "parses multiple rules")
    testing.run(t, should_parse_multiple_rules(t))

    testing.cleanup(t)
    return 0
}

parser.Matcher* build_matcher(chr* pattern) {
    f := testing.tempfile(pattern)
    ctx := parser.new_context(f)
    matcher := parser.parse_matcher(ctx)

    sys.free((chr*) ctx)
    return matcher
}

int should_parse_one_word_matcher(testing.T* t) {
    matcher := build_matcher("NUMBER")

    -- testing.assert_not_null(t, (chr*) matcher)
    testing.assert_null(t, (chr*) matcher.children)
    testing.assert_equal_chr(t, '1', matcher.times)
    testing.assert_equal_chr(t, '&', matcher.mode)
    testing.assert_not_null(t, (chr*) matcher.querys)

    qs := matcher.querys
    testing.assert_equal_chr(t, 'r', qs.type)
    testing.assert_null(t, (chr*) qs.next)
    testing.assert_equal_str(t, "NUMBER", qs.value)
    return 0
}

int should_parse_two_consecutive_tokens(testing.T* t) {
    matcher := build_matcher("a b")

    testing.assert_null(t, (chr*) matcher.children)

    qs := matcher.querys
    testing.assert_equal_str(t, "a", qs.value)
    testing.assert_not_null(t, (chr*) qs.next)
    if qs.next == null {
        return 0
    }
    testing.assert_equal_str(t, "b", qs.next.value)

    return 0
}

int should_parse_repeating_condition_plus(testing.T* t) {
    matcher := build_matcher("a + ")
    testing.assert_equal_chr(t, '+', matcher.times)
    return 0
}

int should_parse_repeating_condition_times(testing.T* t) {
    matcher := build_matcher("a * ")
    testing.assert_equal_chr(t, '*', matcher.times)
    return 0
}

int should_parse_or_condition(testing.T* t) {
    matcher := build_matcher("(a | b)")

    testing.assert_equal_chr(t, '|', matcher.mode)
    testing.assert_null(t, (chr*) matcher.querys)
    testing.assert_equal_chr(t, '1', matcher.times)

    return 0
}

int should_parse_repeating_condition_question(testing.T* t) {
    matcher := build_matcher("(a b)?")
    testing.assert_null(t, (chr*) matcher.querys)
    testing.assert_equal_chr(t, '?', matcher.times)
    return 0
}

int should_parse_matching_rule(testing.T* t) {
    f := testing.tempfile("rule_name: example pattern")
    ctx := parser.new_context(f)
    rule := parser.parse_rule(ctx)
    sys.free((chr*) ctx)

    testing.assert_equal_str(t, "rule_name", rule.name)
    testing.assert_equal_str(t, "example", rule.matcher.querys.value)
    testing.assert_equal_str(t, "pattern", rule.matcher.querys.next.value)
    return 0
}

int should_parse_multiple_rules(testing.T* t) {
    f := testing.tempfile("rule_name: first a\0Asecond: b")
    ctx := parser.new_context(f)
    grammar := parser.parse_grammar(ctx)

    testing.assert_equal_str(t, ctx.current_token.type, "EOF")
    sys.free((chr*) ctx)

    rule0 := grammar[0]
    testing.assert_equal_str(t, "rule_name", rule0.name)

    rule1 := grammar[1]
    testing.assert_equal_str(t, "second", rule1.name)
    return 0
}
