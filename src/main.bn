#!/usr/bin/env coffee
import "./std/io" as io
import "./std/ioutil" as ioutil
import "./std/sys" as sys
import "./std/string" as string
import "./std/compile/init" as compile

import "./std/ast/peeker" as peeker
import "./std/ast/parser" as parser
import "./std/ast/errors" as errors
import "./std/ast/lexer" as lexer


int main(int argc, str* argv) {
    check_args(argc, argv)

    stderr := io.fdopen(io.STDERR, "w")

    filename := argv[1]

    llvm_code := io.tmpfile()
    compiler_ctx := compile.new_context(llvm_code, filename)
    if compile.compile_file(compiler_ctx, (parser.Node*) null, filename) {
        io.fprintf(stderr, "Compilation to llvm interrupted.\0A")
        return 1
    }

    -- check for compiler error

    io.fflush(llvm_code)
    llvm_code_size := io.ftell(llvm_code)
    io.rewind(llvm_code)
    proc := sys.popen("tee debug.ll | llc - -o out.s", "w")

    ioutil.copy(io.fileno(proc), io.fileno(llvm_code))

    if proc == null {
        io.fprintf(stderr, "unable to spawn subprocess\n")
        return 0
    }

    if sys.pclose(proc) != 0 {
        io.fprintf(stderr, "error on llc execution\0A")
        return 0
    }

    cc_proc := sys.popen("cc out.s -o out", "w")
    if cc_proc == null {
        io.fprintf(stderr, "unable to spawn subprocess\n")
        return 0
    }
    if sys.pclose(proc) != 0 {
        io.fprintf(stderr, "error on cc execution")
    } else {
        io.printf("File %s compiled successfully!\0A", filename)
    }

    return 0
}


-- check how the program was called, assuring at least one argument is present in argv
void check_args(int argc, str* argv) {
    if argc == 2 {
        return
    }

    tmpl := "Usage: %s <filename>"
    int len_filename = string.strlen(argv[0]) + string.strlen(tmpl)
    chr* buf = sys.malloc(len_filename)
    io.sprintf(buf, tmpl, argv[0])

    io.puts(buf)
    sys.free(buf)
    sys.exit(1)
}
