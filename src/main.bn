#!/usr/bin/env coffee
import "./std/io" as io
import "./std/sys" as sys
import "./std/string" as string

import "./peeker" as peeker
import "./parser" as parser
import "./errors" as errors
import "./lexer" as lexer
import "./compile/init" as compile


int main(int argc, str* argv) {
    check_args(argc, argv)

    grammar_file := io.fopen("./syntax.txt", "r")
    ctx := parser.new_context(grammar_file)
    grammar := parser.parse_grammar(ctx)
    sys.free((chr*) ctx)

    int fd = io.open(argv[1], io.O_RDONLY)
    sys.assert(fd > 0, "Unable to open input file\0A")
    p := peeker.new(fd)
    tokens := lexer.tokenize(p, false)
    sys.free((chr*) p)

    res := parser.ast(grammar, "start", tokens)
    sys.free((chr*) tokens)

    if res.err != null {
        -- file contains syntaxerrors, the ast
        -- was not created successfully,
        -- aborting

        errors.report(res.err)
        sys.free((chr*) res.err)
        io.close(fd)
        return 0
    }

    stderr := io.fdopen(io.STDERR, "w")

    llvm_code := io.tmpfile()

    -- write IR on llc popen
    compiler_ctx := compile.new_context(llvm_code, argv[1])
    if compile.compile(compiler_ctx, res.node) {
        io.fprintf(stderr, "Compilation to llvm interrupted.\0A")
        return 1
    }

    -- check for compiler error

    io.fflush(llvm_code)
    llvm_code_size := io.ftell(llvm_code)
    io.rewind(llvm_code)
    proc := sys.popen("tee debug.ll | llc - > out.s", "w")

    io.sendfile(io.fileno(proc), io.fileno(llvm_code), (int*) null, llvm_code_size)

    if proc == null {
        io.fprintf(stderr, "unable to spawn subprocess\0A")
        return 0
    }

    if sys.pclose(proc) != 0 {
        io.fprintf(stderr, "error on llc execution")
    }

    gcc_proc := sys.popen("gcc out.s -o out", "w")
    if gcc_proc == null {
        io.fprintf(stderr, "unable to spawn subprocess\0A")
        return 0
    }
    if sys.pclose(proc) != 0 {
        io.fprintf(stderr, "error on gcc execution")
    } else {
        io.printf("File %s compiled successfully!\0A", argv[1])
    }

    io.close(fd)
    return 0
}


-- check how the program was called, assuring at least one argument is present in argv
void check_args(int argc, str* argv) {
    if argc == 2 {
        return
    }

    tmpl := "Usage: %s <filename>"
    int len_filename = string.strlen(argv[0]) + string.strlen(tmpl)
    chr* buf = sys.malloc(len_filename)
    io.sprintf(buf, tmpl, argv[0])

    io.puts(buf)
    sys.free(buf)
    sys.exit(1)
}
