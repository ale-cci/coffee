import "./std/testing" as testing
import "./std/string" as string
import "./std/sys" as sys
import "./std/io" as io

import "./errors" as errors
import "./parser" as parser
import "./peeker" as peeker
import "./lexer" as lexer


int main() {
    t := testing.init("./syntax.test.bn")

    testing.setup(t, "grammar parses empty function")
    testing.run(t, test_grammar_parses_empty_function(t))

    testing.setup(t, "test_parses_atom")
    testing.run(t, test_parses_atom(t))

    testing.setup(t, "test_parses_struct")
    testing.run(t, test_parses_struct(t))

    testing.setup(t, "test_parses_function_arguments")
    testing.run(t, test_parses_function_arguments(t))

    testing.cleanup(t)
    return 0
}


chr* node_to_string(parse.Node* n) {
    tmp := io.tmpfile()
    _node_to_string(n, tmp, 1)
    str_len := io.ftell(tmp)

    tmp_fd := io.fileno(tmp)
    io.lseek(tmp_fd, 0, SEEK_SET)


    chr* buf = sys.malloc(str_len)
    read := io.read(tmp_fd, buf, str_len)

    if read != str_len {
        sys.free(buf)
        buf = null
    }
    return buf
}

void print_indent(io.File* stdout, int indent){
    io.fprintf(stdout, "\0A")
    for i := 0; i < indent; i = i + 1 {
        io.fprintf(stdout, "  ")
    }
}

void _node_to_string(parse.Node* node, io.File* stdout, int indent) {
    if node == null {
        io.fprintf(stdout, "(null)")
        return
    }
    io.fprintf(stdout, "{")
    print_indent(stdout, indent)
    io.fprintf(stdout, "\22type\22: \22%s\22", node.type)
    print_indent(stdout, indent)
    io.fprintf(stdout, "\22value\22: %s", node.value)
    print_indent(stdout, indent)
    io.fprintf(stdout, "\22line\22: %d", node.line)
    print_indent(stdout, indent)
    io.fprintf(stdout, "\22char_of_line\22: %d", node.char_of_line)

    -- for now avoid recursive call loop
    -- print_indent(stdout, indent)
    -- io.fprintf(stdout, "\22parent\22: ")
    -- _node_to_string(node.parent, stdout, indent + 1)

    print_indent(stdout, indent)
    io.fprintf(stdout, "\22next\22: ")
    _node_to_string(node.next, stdout, indent + 1)

    print_indent(stdout, indent)
    io.fprintf(stdout, "\22children\22: ")
    _node_to_string(node.children, stdout, indent + 1)

    print_indent(stdout, indent - 1)
    io.fprintf(stdout, "}")
}


parser.ParseResult* match_rule(chr* rule_name, chr* program) {
    grammar_file := io.fopen("syntax.txt", "r")
    ctx := parser.new_context(grammar_file)
    grammar := parser.parse_grammar(ctx)

    sys.free((chr*) ctx)

    tmp := testing.tempfile(program)
    fd := io.fileno(tmp)
    p := peeker.new(fd)
    tokens := lexer.tokenize(p, false)

    sys.free((chr*) p)
    res := parser.ast(grammar, rule_name, tokens)
    sys.free((chr*) tokens)
    sys.free((chr*) grammar)

    return res
}


parser.Node* new_node(chr* type, value, int line, char_of_line, parser.Node* next, children) {
    parser.Node* n = (parser.Node*) sys.malloc(Node_size)
    n.type = type
    n.value = value
    n.next = next
    n.children = children
    n.line = line
    n.char_of_line = char_of_line

    for bc := children; bc != null; bc = bc.next {
        bc.parent = n
    }
    return n
}

void assert_node_eq(testing.T* t, parser.Node* a, b) {
    repr_a := node_to_string(a)
    repr_b := node_to_string(b)

    testing.assert_equal_str(t, repr_a, repr_b)

    sys.free(repr_a)
    sys.free(repr_b)
}


int test_grammar_parses_empty_function(testing.T* t) {
    res := match_rule("type", "void")

    if res.err != null {
        errors.report(res.err)
        sys.free((chr*) res.err)
        sys.free((chr*) res)
        return 0
    }

    void_type := new_node("WORD", "void", 1, 1, (Node*) null, (Node*) null)
    n := new_node("type", (chr*) null, 1, 1, (Node*) null, void_type)

    assert_node_eq(t, res.node, n)
    sys.free((chr*) res)
    return 0
}


int test_parses_atom(testing.T* t) {
    res := match_rule("atom", "a.b[3]")
    testing.assert_null(t, (chr*) res.err)

    if res.err != null {
        errors.report(res.err)
        sys.free((chr*) res.err)
        sys.free((chr*) res)
        return 0
    }

    -- repr := node_to_string(res.node)
    -- io.printf("Value of node: %s\0A", repr)
    -- sys.free((chr*) res)
    return 0
}

int test_parses_struct(testing.T* t) {
    res := match_rule("structdef", "struct {\0Aint t,\0A}")
    testing.assert_null(t, (chr*) res.err)

    if res.err != null {
        errors.report(res.err)
        sys.free((chr*) res.err)
        sys.free((chr*) res)
        return 0
    }

    return 0
}


int test_parses_function_arguments(testing.T* t) {
    res := match_rule("fn_args", "(int t)")
    testing.assert_null(t, (chr*) res.err)

    return 0
}
