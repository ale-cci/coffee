-- import "./std/test_mockup" as test
import "./std/io" as io
import "./std/sys" as sys
import "./peeker" as peeker
import "./std/testing" as testing


int main() {
    t := testing.init("peeker.test.bn")

    testing.setup(t, "reads characters from file descriptor")
    testing.run(t, peeker_reads_chars(t))


    testing.setup(t, "peeker can seek in file position")
    testing.run(t, peeker_can_seek(t))
    -- test.run(t, peeker_can_seek())

    testing.cleanup(t)
    return 0
}


int peeker_reads_chars(testing.T* t) {
    -- write to input pipe, read from output pipe
    int* pipes = new_pipe()
    p := peeker.new(pipes[io.STDIN])
    write_n_close(pipes[io.STDOUT], "abc")

    testing.assert_equal_chr(t, 'a',   peeker.read(p))
    testing.assert_equal_chr(t, 'b',   peeker.read(p))
    testing.assert_equal_chr(t, 'c',   peeker.read(p))
    testing.assert_equal_chr(t,'\00', peeker.read(p))
    testing.assert_equal_chr(t, '\00', peeker.read(p))
    testing.assert_true(t, "reach EOF", p.eof)

    sys.free((chr*) pipes)
    return 0
}

int peeker_can_seek(testing.T* t) {
    fd := io.fopen("/tmp/test.txt", "w")
    io.fprintf(fd, "abc")
    io.fclose(fd)

    fd = io.fopen("/tmp/test.txt", "r")
    f_no := io.fileno(fd)

    p := peeker.new(f_no)
    peeker.read(p)
    peeker.seek(p, 0)

    testing.assert_equal_chr(t, 'a', peeker.read(p))

    io.fclose(fd)
    return 0
}


void write_n_close(int fd, str string) {
    int length = io.strlen(string) + 1
    sys.assert(io.write(fd, string, length) == length, "Not all bytes were written")
    io.close(fd)
}


int* new_pipe() {
    int* fds = (int*) sys.malloc(32 * 2)
    sys.assert(sys.pipe(fds) == 0, "Unable to create pipe")
    return fds
}
